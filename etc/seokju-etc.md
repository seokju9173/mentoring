# ETC
## 블락 논블락/싱크 어싱크
-	제어권 : 제어권은 자신(함수)의 코드를 실행할 권리 같은 것이다. 제어권을 가진 함수는 자신의 코드를 끝까지 실행한 후, 자신을 호출한 함수에게 돌려준다.
-	결과값을 기다린다는 것 : A 함수에서 B 함수를 호출했을 때, A 함수가 B 함수의 결과값을 기다리느냐의 여부를 의미한다.

### 동기(Synchronous)
-	동시에 일어난다는 의미이다.
-	작업을 동시에 수행하거나, 동시에 끝나거나, 끝나는 동시에 시작
-	함수를 호출하는 곳에서 호출되는 함수가 결과를 반환할 때까지 기다린다.
-	작업 완료 여부를 계속해서 확인한다.

### 비동기(Asynchronous)
-	동시에 일어나지 않음을 의미한다.
-	시작, 종료가 일치하지 않으며, 끝나는 동시에 시작을 하지 않음
-	함수를 호출하는 곳에서 결과를 기다리지 않고, 다른 함수(callback)에서 결과를 처리한다.
-	작업 완료 여부를 확인하지 않는다.

### 블로킹(Blocking)
-	특정 작업이 실행 요청을 받아서 실행하는 동안 다른 작업은 진행하지 못하고 대기하는 방식을 의미한다.
-	제어권이 호출된 함수에게 넘어가서 호출된 함수 내에서 작업이 모두 끝난 후 값이 리턴되고, 호출한 함수에게 다시 제어권이 넘어온다.
-	작업이 완료된 후 새로운 작업을 수행할 수 있다.
-	작업이 순차적으로 이루어지므로 작업 흐름을 쉽게 이해할 수 있다는 장점이 있다.
-	블로킹이 이루어지는 동안 하드웨어 리소스를 효율적으로 이용하지 못한다는 단점이 있고, 특히 블로킹이 일어나는 작업이 오래 걸리는 작업인 경우 이러한 단점은 더욱 부각된다.

### 논블로킹(Non-Blocking)
-	특정 작업이 이미 수행중이어도, 그것과 상관없이 바로 다른 작업을 수행시키는 방식을 의미한다.
-	제어권이 계속 호출한 함수에 있기 때문에 작업의 완료여부와 관계없이 새로운 작업을 수행할 수 있다.
-	작업 흐름이 복잡해져서 이해가 쉽지 않다는 단점이 있다.
-	리소스가 낭비되는 시간이 없으므로, 하드웨어 리소스를 효율적으로 이용할 수 있다.

### 동기/블로킹
-	실행 흐름이 순차적이고 프로그램을 제어하기 쉽다.
-	호출된 함수의 작업이 끝날 때까지 아무것도 하지 않으며 기다린다.
-	예) 팀장은 A 사원에게 어떤 작업을 시킨 후 A 사원의 작업이 끝날 때까지 아무것도 하지 않으며 기다린다.
### 동기/논블로킹
-	호출한 함수는 호출된 함수의 작업이 끝날 때까지 기다리며 그 동안 다른 작업을 진행할 수 있다.
-	예) 팀장은 A 사원에게 어떤 작업을 시킨 후 A 사원의 작업 완료 여부를 지속적으로 확인하면서 자신의 일을 한다.
### 비동기/블로킹
-	호출한 함수는 호출된 함수의 작업 완료에 신경 쓰지 않지만 호출된 함수가 작업을 완료할 때까지 아무것도 하지 않는다.
-	예) 팀장은 A 사원에게 어떤 작업을 시켰는데, A 사원이 계속 작업 관련해서 팀장을 붙들고 있고, A 사원의 작업이 끝날 때까지 팀장을 놓아주지 않는다.
### 비동기/논블로킹
-	호출한 함수는 호출된 함수의 작업 완료 여부는 신경 쓰지 않고 자신의 작업을 진행한다.
-	예) 팀장은 A 사원에게 어떤 작업을 시킨 후 자신은 다른 업무를 보기 시작한다. 이 후 A 사원이 일을 마친 후 팀장에게 보고한다.
-	**가장 효율적인 방식** 
## WebServer VS WebApplicationServer 
WebServer(웹 서버)와 WebApplicationServer(웹 애플리케이션 서버)의 차이를 알기 이전에 Static pages(정적 페이지), Dynamic pages(동적 페이지)에 대해 알아본다.
+ **Static pages(정적 페이지)**
  + image, html, css, javascript 파일과 같이 컴퓨터에 저장되어 있는 파일을 의미한다.
  + 웹 서버에서 요청에 알맞은 파일을 반환하며, 항상 동일한 페이지를 반환한다. (정적인 컨텐츠)
  + **웹 서버**에서 제공한다.
+ **Dynamic pages(동적 페이지)**
  + 들어온 요청에 맞게 동적으로 만들어진 컨텐츠를 의미한다.
  + 데이터베이스, 서버 내 로직 등을 활용해 만들어진 컨텐츠를 반환한다.
  + **웹 애플리케이션 서버**에서 제공한다.

### Web Server (웹 서버)
#### HTTP 요청을 받아 Static contents를 제공하는 서버, 프로그램
+ HTTP 프로토콜을 기반으로 하여 클라이언트의 요청을 서비스하는 기능을 담당
  + 정적인 컨텐츠 제공
    + WAS를 거치지 않고, 바로 요청한 컨텐츠를 제공할 수 있다.
  + 동적인 컨텐츠 제공을 위한 요청 전달
    + 요청을 WAS에 보내고, WAS가 처리한 결과를 클라이언트에게 전달한다.
  + 종류 : Apache, Nignx, IIS 등

### Web Application Server
#### 다양한 서버 내 알고리즘, 비즈니스 로직, DB 조회 등 클라이언트 요청에 따라 동적인 컨텐츠를 제공하는 서버, 프로그램
  + HTTP 프로토콜을 기반으로 하여 클라이언트의 요청에 따라 구현된 비즈니스 로직을 통해 동적으로 만들어진 컨텐츠를 반환
  + 데이터베이스 접속 기능, 여러 개의 트랜잭션 관리 등 수행
  + 종류 : Apache Tomcat, JEUS, Jetty, Resin 등
  + WAS = Web Server + Web Container라는 곳도 있고, WAS = Web Server + APP 간의 미들웨어 라는 곳도 있고, WAS = WAS + APP 이라고 한 번에 모든 기능을 한다는 곳도 있다. 하지만 대부분의 경우 Web Server + Web Container 라고 설명한다.
> Container (컨테이너)
> 웹 서버가 보낸 JSP, PHP, ASP.net 등의 파일들을 실행하고 수행결과를 다시 웹 서버로 보내는 역할

결국, 웹 애플리케이션 서버는 웹 서버에서 요청을 받고, 이를 웹 컨테이너로 보내 로직(알고리즘, DB 연결 등)을 수행하고 그 결과를 다시 웹 서버로 보내 최종적으로 클라이언트에 보내주는 것이다.

### WAS가 Web Server의 모든 기능을 수행하지 않고, Web Server를 사용하는 이유
+ **기능을 분리하여 서버 부하를 방지한다.**
  + WAS는 DB 조회, 다양한 로직을 수행하느라 바쁘기 때문에 단순한 정적 컨텐츠는 Web Server에서 빠르게 클라이언트에 제공하는 것이 좋다.
  + 정적 컨텐츠 요청까지 WAS에서 수행하게 되면 부하가 커지게 되고, 동적 컨텐츠 처리가 지연됨에 따라 수행속도가 느려진다.
+ **물리적으로 분리하여 보안을 강화시킨다.**
  + SSL에 대한 암복호화 처리에 Web Server를 사용한다.
+ **여러 대의 WAS를 연결해 로드 밸런싱 용도로 사용할 수 있다.**
  + 로드 밸런싱 (load balancing, 부하 분산) : 둘 혹은 셋 이상의 중앙처리장치 혹은 저장장치와 같은 컴퓨터 자원들에게 작업을 나누는 것을 의미
  + Fail over (장애 조치), Fail back (장애 복구) 처리에 유리하다.
    + Fail over : 시스템, 서버, 네트워크 이상이 생겼을 경우 예비시스템으로 전환되는 기능
    + Fail back : Fail over에 따라 전환된 서버/시스템/네트워크를 장애 발생 전으로 되돌리는 처리
  + 대용량 웹 애플리케이션의 경우, Web Server와 WAS를 분리하여 오류가 발생한 WAS를 사용하지 않고, 다른 WAS를 사용하게 만듦으로써 무중단 운영을 가능하게 한다.
+ **여러 언어의 웹 애플리케이션 서비스가 가능하다.**
  + 하나의 서버에서 PHP Application, Java Application을 함께 사용하는 등과 같이 여러 웹 애플리케이션의 활용이 가능해진다.
  + 톰캣은 Java의 언어만 해석이 가능하다. JSP 같은 경우, 처리가 가능하지만 PHP는 실행이 불가능하다. 그러므로 Web Server로 아파치를 사용해 PHP를 사용할 수 있게 만들 수 있다.
#### 결론적으로, 자원 이용의 효율성 및 장애 극복, 배포 및 유지보수의 편의성을 위해 Web Server, Web Application Server를 각기 사용한다.
 
## Monolithic service Application VS Micro Service Application
 ![image](https://user-images.githubusercontent.com/85390517/186663699-6cb9ea04-71b3-44f0-b719-57b988673243.png)


### Monolithic Service Architecture
-	Micro Service Architecture가 각광을 받기 시작하면서 기존의 아키텍처를 지칭하는 의미로 생겨난 단어
-	모든 모듈은 하나의 서비스 내부에 종속되어 있으며 서비스 자체에 집중할 수 있는 구조로 되어있다.
-	다시말해 각기 다른 역할을 하는 모듈들이 모여서 하나의 프로젝트를 이룬다는 것이다.
+ 장점
  + 단순한 구조
  + 개발환경과 방법의 통일성
  + 배포가 간편
  + End to End 테스트가 쉬움
+ 단점
  + 프로젝트의 규모가 커질수록 복잡도가 심각하게 증가
  + 코드 전체를 이해하기 힘듦
  + 빌드 시간의 증가 (CI/CD 불가)
  + 새로운 기술을 적용하려면 프로젝트를 다 뜯어고쳐야 할 수 있음
 
### MSA, Micro Service Application
-	기존 Monolithic 아키텍처의 단점을 보완하고자 나온 여러 아키텍처 중 하나
-	작은 서비스 여러 개가 모여서 하나의 시스템을 제공하는 아키텍처를 뜻함
-	서비스가 독립적이라는 특징 덕에 클라우드와 컨테이너와 잘 어울리는 아키텍처
+ 장점
  + 전체 프로그램을 다시 배포하지 않고도 업데이트가 가능
  + 독립적으로 개발 가능
  + 서비스 하나가 다운되더라도 전체 서비스에 영향을 끼치지 않음
  + 서비스를 독립적으로 확장 가능, 리소스의 유연한 운용 가능
+ 단점
  + 서비스간 통신 방법이 필요하고 복잡함
  + 서비스끼리의 테스트가 어려움
  + 복잡하고 독립된 구조로 인해 통합적인 유지관리가 어려워질 수 있음

### MSA를 사용하는 이유
-	MSA가 클라우드 환경과 잘 맞기 때문
-	Monolithic 구조는 각각의 모듈들이 합쳐져 큰 덩어리로 시스템이 구축되어 있다.
-	사용량이 적은 모듈을 삭제한다고 하더라도 전체 시스템의 스펙은 변하지 않기 때문에 사용량 단위로 과금을 해야 하는 클라우드 환경에 비효율적
-	MSA는 서비스 단위로 기능을 분리해서 구축할 수 있기 때문에, 사용하지 않는 기능 또는 사용량이 적은 기능을 축소해서 효율화 시킬 수 있다.
-	MSA로 시스템을 구축하게 되면 그에 따른 서비스들도 늘어나게 되고 관리해야 할 포인트가 증가하는 단점이 있지만, 서비스들의 재사용성과 클라우드 환경에 친화적이라는 장점이 있다. 
## Multi Module VS MSA
### 모듈이란?
-	프로그램의 기능을 독립적인 부품으로 분리한 것
-	특정 기능별로 나누어지는 프로그램 덩어리, 프로그램의 꾸러미라고 생각하면 된다.

### 멀티모듈이란?
-	한 프로젝트 안에 라이브러리처럼 사용 가능한 상태로 모듈을 구성하고 그것들을 다른 모듈에서 가져다 쓸 수 있도록 만드는 것
-	서로 독립적인 프로젝트(인증, 애플리케이션)를 하나의 프로젝트로 묶어 모듈로서 사용되는 구조
-	멀티 모듈을 사용하면 공통적인 기능을 모아 하나의 모듈로 만드는 것이 가능하다. 즉, 인증과 애플리케이션에서 공통으로 사용하는 util, domain, Repository 등을 모듈로 사용할 수 있는 것이다.

### 멀티 모듈의 장점
+ **재사용, 공유할 수 있다.**
  + 멀티 모듈의 각 모듈들은 독립적이고 필요한 최소 의존성을 가지고 있기 때문에 다른 영향을 고려하지 않고 재사용이 가능하다.
+ **빌드를 쉽게 할 수 있다.**
  + 멀티 프로젝트의 경우에는 각 프로젝트마다 빌드를 해줘야 한다. 하지만 멀티 모듈은 최상위 모듈에서 전체 프로젝트를 빌드할 수 있다는 점이 큰 장점이다.
+ **변경으로 인한 영향이 최소화**
  + 버그를 발견하면 전체 시스템이 아닌 버그가 포함된 모듈만 업데이트하면 된다.
+ **하나의 모듈을 업데이트할 때 관련 프로젝트 전체를 이해할 필요가 없다.**
  + 각 모듈이 갖는 책임과 역할이 명확해 리팩토링, 기능 변경 영향을 파악하기가 쉬워졌기 때문
+ **의존성을 최소화**
  + 의존성을 최소화하면 우선 변경으로 인한 영향을 최소화할 수 있다. 즉, 결합도가 낮아진다.
  + 각 모듈을 가볍게 유지해서 빌드 시간을 줄이고 생산성을 향상시킬 수 있다.

### 멀티 모듈의 단점
-	멀티 모듈 학습에 대한 비용이 생긴다.
-	익숙하지 않은 멀티 모듈로 인해 예상치 못한 에러가 나고 시간이 소요된다.
-	여러 모듈을 유지 관리하기가 더 어려울 수 있다.
-	기능이 추가될수록 처음 설계와 다르게 의존성이 꼬일 가능성이 높다.

#### 프로젝트가 커지면 커질수록 멀티 모듈은 거의 필수가 된다고 한다.
#### 하지만 크기가 작은 프로젝트의 경우에는 멀티 모듈의 장점을 살릴 수 없는 의미 없는 멀티 모듈이 될 확률이 높다.
#### 멀티 모듈은 Monolithic <-> MSA간 서로 전환하는 작업을 수월하게 할 수 있는 구조가 되도록 도와준다.
 
## NginX VS Apache
Nginx와 Apache는 웹 서버를 운영할 수 있는 오픈 소스 서버 기술을 제공한다.
사이트를 최대한 효율적으로 운영하려면 가장 적합한 서버 유형을 선택하는 것이 중요하다.

### APACHE
아파치는 NGINX보다 훨씬 오래 사용되어 왔으며 여전히 많은 사이트 소유자와 개발자들이 사용하고 있다. 거의 모든 OS에서 실행되며 다른 유명한 소프트웨어 프로젝트와의 훌륭한 문서화 및 통합 지원의 이점이 있다.
+ Apache의 장점
  + 클라이언트 요청을 처리하기 위해 멀티 스레드 방식을 따른다.
  + 웹 서버 자체 내에서 동적 컨텐츠를 처리한다.
  + 모듈을 동적으로 로드 및 언로드
+ 단점
  + 웹 트래픽이 많아지면 Apache가 여러 요청을 동시에 처리할 수 없다.
  + 클라이언트 요청을 처리하기 위한 다중 스레드 접근 방식을 따르고 각 스레드는 한 번에 하나의 연결만 처리할 수 있기 때문이다.

### NGINX
Apache와 달리 NGINX는 오늘날 웹의 요구를 처리하도록 설계되었다. 효율성에 중점을 두고 있으며 경량 아키텍처와 높은 동시성이 있다.
+ NGINX의 장점
  + 이벤트 중심 접근 방식을 사용하여 클라이언트 요청 제공
  + 제한된 하드웨어 리소스로도 여러 클라이언트 요청을 동시에 효율적으로 처리
  + 단일 스레드를 통해 여러 연결을 처리할 수 있다.
  + 최소한의 리소스로 웹 서버의 아키텍처를 개선하기 위해 독립형 HTTP 서버로 배치 가능
+ 단점
  + 동적 컨텐츠를 기본적으로 처리할 수 없다.
  + 동적 컨텐츠에 대한 PHP 및 기타 요청을 하려면 NGINX가이를 실행하기 위해 외부 프로세스로 전달하고 렌더링 된 컨텐츠가 다시 전송될 때까지 기다려야 하기 때문에 프로세스 속도가 저하된다는 단점이 있다.

### 결론
-	Apache는 .htacess 파일을 제공하기 때문에 이를 활용하거나 NGINX에 없는 핵심 모듈을 사용할 경우 Apache를 사용
-	빠른 정적 컨텐츠를 처리하고 싶고 대용량 트래픽을 처리하는 웹 사이트인 경우 NGINX
-	또한, 두 서버를 함께 사용해도 된다. Apache 앞단에 Nginx를 프록시 서버로 활용할 수 있다.
 
## Servlet VS Netty
 ![image](https://user-images.githubusercontent.com/85390517/186663760-992f4ce4-5e85-4e64-86ce-0c28a798f196.png)


### Servlet
-	**Servlet(서블릿)** 이란 동적 웹 페이지를 만들 때 사용되는 자바 기반의 웹 애플리케이션 프로그래밍 기술이다. 서블릿은 웹 요청과 응답의 흐름을 간단한 메서드 호출만으로 체계적으로 다룰 수 있게 해준다.
-	기존의 서버는 정적인 자료(HTML, 사진, 글 등)만을 주고받았다. 하지만 웹에 다양한 기능이 요구되면서 정적인 자료 뿐만 아니라 사용자의 요구에 맞춘 동적인 페이지들을 만들 필요가 생겼고, 이를 위해 만들어진 것이 서블릿이다.

### Servlet의 주요 특징
-	클라이언트의 요청(Request)에 대해 동적으로 작동하는 웹 애플리케이션 컴포넌트
-	HTML을 사용하여 응답(Response)한다.
-	JAVA의 스레드를 이용하여 동작한다.
-	MVC 패턴에서의 컨트롤러로 이용된다.
-	HTTP 프로토콜 서비스를 지원하는 javax.servlet.http.HttpServlet 클래스를 상속받는다.
-	UDP보다 속도가 느리다.
-	HTML 변경 시 Servlet을 재 컴파일해야 하는 단점이 있다.

### 서블릿 컨테이너
서블릿 컨테이너란 말 그대로 서블릿을 담고 관리해주는 컨테이너이다. <br/>
서블릿 컨테이너는 구현되어있는 servlet 클래스의 규칙에 맞게 서블릿을 관리해주며 클라이언트에서 요청을 하면 컨테이너는 HttpServletRequest, HttpServletResponse 두 객체를 생성하며 post, get 여부에 따라 동적인 페이지를 생성하여 응답을 보낸다.
+ HttpServletRequest
  + http 프로토콜의 request 정보를 서블릿에게 전달하기 위한 목적으로 사용하며 헤더 정보, 파라미터, 쿠키, URI, URL 등의 정보를 읽어 들이는 메서드와 Body의 Stream을 읽어 들이는 메서드를 가지고 있다.
+ HttpServletResponse
  + WAS는 어떤 클라이언트가 요청을 보냈는지 알고 있고, 해당 클라이언트에게 응답을 보내기 위한 HttpServletResponse 객체를 생성하여 서블릿에게 전달하고 이 객체를 활용하여 content type, 응답 코드, 응답 메시지 등을 전송한다.

#### 서블릿 컨테이너의 주요 기능
-	생명주기 관리
-	통신 지원
-	멀티스레딩 관리
-	선언적인 보안관리

### Netty
-	비동기 이벤트 기반 네트워크 응용프로그램 프레임워크
-	서버 및 클라이언트에 필요한 네트워크 애플리케이션을 빠르고 쉽게 개발이 가능하게 해주는 NIO(Non-Blocking Input Output) 기반의 서버 프레임워크
-	TCP, UDP 모두 지원한다.

#### Netty를 사용하는 이유
-	순수 NIO만을 이용해서 네트워크 애플리케이션을 작성하는 일은 매우 어렵고 비효율적이다. 때문에 예상치 못한 버그를 만들어 낼 수 있다.
-	Netty는 자바 네트워크 프레임워크로서 자바 환경에서 네트워크 프로그래밍을 손쉽게 할 수 있게 해주며 고성능, 고안정성의 프로그램을 만들 수 있게 해준다.

### Netty 프레임워크의 특징
+ **Asynchronous IO (비동기 입출력)**
  + Netty 프레임워크는 비동기처리를 지향한다.
  + 요청을 보낸 후 즉시 리턴 된 다음, 다른 작업을 하다가 요청한 작업의 처리가 완료되었는지 확인한 다음 나중에 응답을 받는 방식이다.
+ **Event Model**
  + Netty는 입출력을 위해 잘 정의된(Well-Defined) 이벤트 모델을 가지고 있다.
  + 사용자가 코어 로직을 손대지 않고도 직접 이벤트 타입을 구현할 수 있도록 지원한다.
+ **Universal Asynchronous I/O API**
  + 자바의 전통적인 I/O API는 TCP, UDP에 따라 다른 형태의 API를 제공한다. 각각의 특성과 성능이 다르기 때문에 개발자가 어떤 것을 이용해서 개발을 해야하는지 미리 결정해야 하는 경우가 종종 있다.
  + Netty는 Channel이라는 Async I/O 인터페이스를 가지고 있다. Netty 앱을 개발하면 추상화를 통해서 실제 통신 부분과 상관없이 로직을 개발할 수 있다.
+ **ChannelBuffer**
  + Netty는 NIO의 ByteBuffer를 사용하지 않고 독자적인 Buffer API를 구현해서 사용했다.
  + ByteBuffer는 버그 발생 확률이 높고 GC가 많이 발생할 수 있다.
 
## 로드밸런싱
-	로드밸런싱은 서버에 가해지는 부하(=Load)를 분산(=Balancing) 해주는 기술을 의미한다.
-	클라이언트와 서버풀(Server Pool, 분산 네트워크를 구성하는 서버들의 그룹) 사이에 위치하며, 한 대의 서버로 부하가 집중되지 않도록 트래픽을 관리해 각각의 서버가 최적의 퍼포먼스를 보일 수 있도록 한다.

### 로드밸런싱은 모든 경우에 항상 필요할까?
-	로드밸런싱은 여러 대의 서버를 두고 서비스를 제공하는 분산 처리 시스템에서 필요한 기술이다.
-	서비스의 제공 초기 단계라면 적은 수의 클라이언트로 인해 서버 한 대로 요청에 응답하는 것이 가능하다. 하지만 규모가 확장되고, 클라이언트의 수가 늘어나게 되면 기존 서버만으로는 정상적인 서비스가 불가능하게 된다. 이처럼 증가한 트래픽에 대처할 수 있는 방법은 크게 두 가지가 있다.

### Scale-up과 Scale-out
 ![image](https://user-images.githubusercontent.com/85390517/186663799-2add3788-6b19-49bd-923f-24158bbe91b5.png)


+ **Scale-up**
  + 서버 자체의 성능을 확장하는 것을 의미
+ **Scale-out**
  + 기존 서버와 동일하거나 낮은 성능의 서버를 두 대 이상 증설하여 운영하는 것을 의미
  + Scale-out 방식으로 결정했다면 여러 대의 서버로 트래픽을 균등하게 분산해주는 로드밸런싱이 반드시 필요하다.

### 로드밸런싱 알고리즘
+ 라운드로빈 방식 (Round Robin Method)
  + 서버에 들어온 요청을 순서대로 돌아가며 배정하는 방식
+ 가중 라운드로빈 방식 (Weighted Round Robin Method)
  + 각각의 서버마다 가중치를 매기고 가중치가 높은 서버에 클라이언트 요청을 우선적으로 배분
+ IP 해시 방식 (IP Hash Method)
  + 클라이언트의 IP 주소를 특정 서버로 매핑하여 요청을 처리하는 방식
+ 최소 연결 방식 (Least Connection Method)
  + 요청이 들어온 시점에 가장 적은 연결상태를 보이는 서버에 우선적으로 트래픽을 배분
+ 최소 리스폰 타임 (Least Response Time Method)
  + 서버의 현재 연결 상태와 응답시간(Response Time, 서버에 요청을 보내고 최초 응답을 받을 때까지 소요되는 시간)을 모두 고려하여 트래픽을 배분

### L4 로드밸런싱과 L7 로드밸런싱
-	**L4 로드밸런서**는 네트워크 계층(IP, IPX)이나 트랜스포트 계층(TCP, UDP)의 정보를 바탕으로 로드를 분산한다. IP 주소나 포트 번호, MAC 주소, 전송 프로토콜에 따라 트래픽을 나누는 것이 가능하다.
-	**L7 로드밸런서**는 애플리케이션 계층(HTTP, FTP, SMTP)에서 로드를 분산하기 때문에 HTTP 헤더, 쿠키 등과 같은 사용자의 요청을 기준으로 특정 서버에 트래픽을 분산하는 것이 가능하다.
 ![image](https://user-images.githubusercontent.com/85390517/186663832-08aa35a0-b3f9-44ad-b44b-abf29caefe64.png)

 
## Reverse Proxy
### 프록시(Proxy)란?
-	프록시의 사전적 의미 : 대신, 대리
-	두 PC가 통신을 할 때 직접 하지 않고 중간에서 대리로 통신을 하는 것을 **프록시**라고 하고, 중계 역할을 하는 것을 **프록시 서버**라고 부른다.
-	클라이언트와 서버 사이의 **중계 서버**라고 생각하면 된다.
-	프록시 서버는 보안 목적이나 캐싱 등의 기능을 제공한다.
 ![image](https://user-images.githubusercontent.com/85390517/186663862-88796bd0-a74c-474f-8b33-67e85fc7075d.png)


-	프록시 서버가 중간에 위치함으로써 클라이언트는 프록시 서버를 ‘서버’로 인식하고, 서버 입장에서는 프록시 서버를 ‘클라이언트’로 인식하게 된다.

### 포워드 프록시 (Forward Proxy)
 ![image](https://user-images.githubusercontent.com/85390517/186663883-05c92b6c-1f74-4cad-990b-8f3d076c1403.png)


-	일반적으로 말하는 프록시
-	클라이언트에서 서버로 리소스를 요청할 때 직접 요청하지 않고 프록시 서버를 거쳐서 요청한다. 이 경우 서버레서 받는 IP는 클라이언트의 IP가 아닌 프록시 서버의 IP이기 때문에 서버는 클라이언트가 누구인지 알 수 없다. 즉, **서버에게 클라이언트가 누구인지 감춰주는 역할**을 한다.
-	포워드 프록시의 특징 : 캐싱 기능, IP 우회 기능, 웹 사용 환경 제한 기능

### 리버스 프록시 (Reverse Proxy)
 ![image](https://user-images.githubusercontent.com/85390517/186663898-c1cacf5b-2c97-4486-9661-d90b8aebd58b.png)


-	포워드 프록시의 반대 개념
-	애플리케이션 서버의 앞에 위치하여 클라이언트가 서버를 요청할 때 리버스 프록시를 호출하고, 리버스 프록시가 서버로부터 응답을 전달받아 다시 클라이언트에게 전송하는 역할을 한다. 이 경우, 클라이언트는 애플리케이션 서버를 직접 호출하는 것이 아니라 프록시 서버를 통해 호출하기 때문에 리버스 프록시는 애플리케이션 서버를 감추는 역할을 하게 된다.
-	리버스 프록시의 예시 : NginX, Apache Web Server
-	리버스 프록시의 특징 : 로드밸런싱, 보안
 
## CDN
-	Content Delivery Network
-	CDN은 지리적 제약 없이 전 세계 사용자에게 빠르고 안전하게 컨텐츠를 전송할 수 있는 컨텐츠 전송 기술을 의미한다.
-	CDN은 서버와 사용자 사이의 물리적인 거리를 줄여 컨텐츠 로딩에 소요되는 시간을 최소화한다. CDN은 각 지역에 캐시 서버(PoP, Points of presence)를 분산 배치해, 근접한 사용자의 요청에 원본 서버가 아닌 캐시 서버가 컨텐츠를 전달한다.
-	지리, 물리적으로 떨어져 있는 사용자에게 컨텐츠를 더 빠르게 제공할 수 있는 기술
-	느린 응답속도 / 다운로딩 타임을 극복하기 위한 기술

### CDN의 장점
-	웹사이트 로딩 속도 개선
-	인터넷 회선 비용 절감
-	컨텐츠 제공의 안정성
-	웹사이트 보안 개선
 
## 캐시
-	캐시란 자주 사용하는 데이터나 값을 미리 복사해 놓는 임시 장소를 가리킨다.
-	캐시는 저장 공간이 작고 비용이 비싼 대신 빠른 성능을 제공한다.

### Local Cache VS Global Cache
+ **Local Cache**
  + Local 장비 내에서만 사용되는 캐시
  + Local 장비의 Resource를 이용한다. (Memory, Disk)
  + Local에서 작동되기 때문에 속도가 빠르다.
  + Local에서만 작동되기 때문에 다른 서버와 데이터 공유가 어렵다.
+ **Global Cache**
  + 여러 서버에서 Cache Server에 접근하여 사용하는 캐시
  + 데이터를 분산하여 저장할 수 있다.
    + Replication – 데이터를 복제
    + Sharding – 데이터를 분산하여 저장
  + Local Cache에 비해 상대적으로 느리다. (네트워크 트래픽)
  + 별도의 Cache Server를 이용하기 때문에 서버 간 데이터 공유가 쉽다.
 
## E-TAG
-	E-TAG(Entity TAG)는 웹 서버가 주어진 URL의 컨텐츠가 변경되었는지 알려주고 이를 반환하는 HTTP 응답 헤더이다.
-	E-TAG는 우리가 사용하는 캐시가 유효한지 검증하기 위해 사용한다. 서버의 리소스가 변경된다면 저장해 놓은 캐시의 데이터와 서버의 리소스 데이터는 다른 값이 된다. 그 때 서버에게 리소스가 변경되었는지 여부를 물어보는 것을 **캐시 유효성 검사**라고 한다.
-	E-TAG를 사용하여 캐시 유효성 검사를 한다.
 
## 성능 테스트
-	성능 테스트란 특정 워크로드에서 애플리케이션의 안정성과 속도, 확장성 및 반응성이 어떻게 유지되는지를 판별하는 비기능적 소프트웨어 테스트 기법이다.
-	소프트웨어 품질을 보장하는 것은 핵심적인 단계이지만, 불행히도 이 단계는 종종 나중에 별개로 고려할 요소라고 간주되곤 하며 기능 테스트가 완료되고 난 후, 그리고 많은 경우에 코드 릴리스 준비가 완료된 후에 시작되곤 한다.
-	성능 테스트의 목표에는 애플리케이션 결과 평가, 처리 속도, 데이터 전송 속도, 네트워크 대역폭 사용량, 최대 동시 사용자 수, 메모리 이용률, 워크로드 효율성, 명령 응답 시간 등이 포함된다.

### Virtual User
Vuser, 주로 퍼포먼스 테스트를 위해 만드는 가상 유저

### TPS(RPS)
Transaction Per Second, 주로 서버 성능의 척도가 된다. 초당 트랜잭션 처리 수를 의미한다.

### MAU/DAU
+ DAU (Daily Active Users)
  + 하루 동안 방문한 사용자 수
  + 전체 세션 수를 무시하고 사용자수를 계산한다. 한 번 방문하든 여러 번 방문하든 한 명의 활성 유저로 집계
+ MAU (Monthly Active User)
  + 한달 동안 방문한 사용자 수
  + DAU와 비슷한 방식으로 한 달 간의 사용자 수를 계산한다.

 
# 기술
## 로깅 라이브러리 비교(스프링/자바 -> 보안 이슈 적지 말아라)

### 로그란?
모든 행위와 이벤트 정보를 시간의 경과에 따라 기록한 데이터

### 로깅
시스템 상에서 ‘로그’를 생성하는 과정을 **‘로깅(Logging)’** 이라고 한다.

### 로깅(Logging)의 장점
-	개발 프로그램의 디버깅
-	예기치 못한 문제의 원인 파악
-	시스템 및 사용자의 동작 패턴 분석
-	해킹(침입)의 비정상 동작의 기록을 감지
-	분석을 통한 통계화
-	**즉, 모든 것을 기록하고 분석하여 예측하게 해주는 장치라고 할 수 있다.**

### 로깅 라이브러리의 종류
로깅 라이브러리는 프로그램을 실행하는 도중에 로그를 남기기 위해 사용되는 유틸리티이다.
+ java.util.logging (jdk8)
  + JDK에 내장된 기본 로깅 라이브러리
  + JDK 1.4부터 포함된 표준 로깅 API
  + 장점
    + 원하는 기능이 아주 기본적인 수준이라면 외부 라이브러리 사용 없이 로깅이 가능하다.
  + 단점
    + 자바 1.4의 시점에 이미 잘 만들어진 log4j가 존재하였고 널리 쓰이고 있었다. 굳이 기존 log4j 사용자들이 jul(java.util.logging)을 사용할 이유가 없었다.
    + 다른 라이브러리와 비교했을 때 속도가 느리다. 
    + 타 라이브러리에 비해 기능이 부족하다.
    + 유연하지 않다.
+ Apache Commons logging
  + Apache 재단의 Commons 라이브러리 중 로그 출력을 제공하는 라이브러리
+ log4j
  + Apache 재단에서 만든 log4j는 2001년에 처음 릴리즈된 자바의 로깅 라이브러리
  + 가장 널리 사용되는 로깅 라이브러리
  + 기능
    + 퍼포먼스가 최적화되어 있다.
    + 여러 종류의 appender를 지원한다.
    + jul에 비해 명확한 기준의 레벨을 가지고 있다.
+ Logback
  + Log4j를 개발한 Ceki Gulcu가 Log4j의 단점 개선 및 기능을 추가하여 개발한 로깅 라이브러리
+ SLF4J
  + SLF4J(Simple Logging Façade For Java)란 Façade Pattern을 적용한 Logging 프레임워크이다.
  + 로깅과 관련된 Interface의 모음이라고 생각하면 된다.
  + SLF4J와 다른 라이브러리의 가장 큰 차이점은 SLF4J는 wrapper라는 것이다.
  + SLF4J를 사용하여 설정에 따라 다른 로깅 라이브러리를 사용할 수 있게 된다.
> wrapper란?
> wrapper의 사전적 의미는 ‘(특히 식품)포장지’라는 뜻이다. 여기서 래퍼 클래스는 기본 자료형(primitive data types)에 대한 클래스 표현을 래퍼 클래스(wrapper class)라고 한다.
> 기본 자료형에 대해서 객체로서 인식되도록 ‘포장’을 했다는 뜻

+ 대부분의 프로젝트는 SLF4J의 사용을 추천한다.
 
## AMQP란?
+ Advanced Message Queueing Protocol
+ 메시지 지향 미들웨어를 위한 표준 응용 프로토콜
+ AMQP를 구성하는 요소는 Exchange, Queue, Binding이 있다.
 ![image](https://user-images.githubusercontent.com/85390517/186663996-fb195e8c-f3cd-49b2-a725-0f87ac806c96.png)


+ Exchange
  + Exchange는 생산자로부터 수신한 메시지를 적절한 큐나 다른 Exchange로 분배하는 라우터의 기능을 한다.
  + Exchange는 수신한 메시지를 분배하기 위해 Exchange Type이라는 라우팅 알고리즘을 사용한다.
+ Queue
  + 메모리나 디스크에 메시지를 저장하고, 그것을 소비자에게 전달하는 역할을 한다.
+ Binding
  + Exchange와 Queue와의 관계를 정의한 일종의 라우팅 테이블이다. 동일한 Queue가 여러 개의 Exchange에 Binding 될 수도 있고 단일 Exchange에 여러 개의 Queue가 Binding 될 수도 있다.
+ Standard Exchange Type
  + Exchange Type은 메시지를 어떤 방법으로 라우팅할지 결정하는 알고리즘이다.
  + AMQP에서는 Standard Exchange Type으로 라우팅 키에 기반한 라우팅 알고리즘과 key-value 헤더에 기반한 1개 유형의 Exchange Type을 정의해야 한다.
  + Direct Exchange
    + 메시지의 라우팅 키를 기반으로 1:N으로 Queue에 매칭시키는 방법
  + Topic Exchange
    + 와일드카드를 이용해서 메시지를 Queue에 매칭시키는 방법
  + Fanout Exchange
    + 모든 메시지를 Queue에 매칭하는 방법
  + Headers Exchange
    + key-value로 정의된 헤더에 의해 메시지를 Queue에 매칭시키는 방법
 
## RabbitMq
-	서버 간에 메시지를 전달해주는 오픈소스 메시지 브로커이다.
-	A -> B 또는 A -> B,C,D,E,F,… 등 메시지를 보내려고 할 때 RabbitMQ가 이 메시지를 받아서 전달해주는 것으로 이해하면 된다.
-	RabbitMQ는 AMQP 프로토콜을 구현한 메시지 브로커이다.

### RabbitMQ에서 메시지를 전송하고 받을 때 구성
 ![image](https://user-images.githubusercontent.com/85390517/186664032-127b6842-f85b-457b-89ac-2559f0581b06.png)

MSA 구조의 서버를 사용하다 보면, 서버와 서버끼리 메시지를 주고받아야 할 때가 있는데, 이때 RabbitMQ를 사용한다.
 ![image](https://user-images.githubusercontent.com/85390517/186664050-65a65d9b-2485-4255-9902-8189fd25d896.png)

-	서버1이 서버2에게 메시지를 보낼 때 RabbitMQ를 통해 메시지를 전송한다. 이때 서버1이 Producer, 서버2가 Consumer가 되는 것이다.
-	반대로, 서버2가 서버1에게 메시지를 보낼 때 서버2가 Producer, 서버1이 Consumer가 되는 것이다.

### RabbitMQ의 특징
-	신뢰성, 안정성
-	유연한 라우팅 (Message Queue가 도착하기 전에 라우팅 되며 플러그인을 이용해서 더 복잡한 라우팅 가능)
-	클러스터링 (로컬네트워크에 있는 여러 RabbitMQ 서버를 논리적으로 클러스터링 할 수 있음)
-	관리 UI의 편리성 (관리자 페이지 및 모니터링 페이지 제공)
-	거의 모든 언어 및 운영체제 지원
-	오픈소스로서 상업적 지원 가능
 
## ActiveMq
-	JMS(Java Message Service) 클라이언트와 함께 자바로 작성된 오픈 소스 메시지 브로커
-	하나 이상의 클라이언트나 서버로부터 통신을 조정시키는 엔터프라이즈 기능들을 제공
-	자바 및 기타 여러 언어 간 클라이언트 지원

### JMS란?
-	JMS는 자바 기반의 MOM(메시지 지향 미들웨어) API이며 둘 이상의 클라이언트 간의 메시지를 보낸다.

### ActiveMQ의 메시지 처리 구조
 ![image](https://user-images.githubusercontent.com/85390517/186664075-446464c5-aa00-40f0-aef4-fb8c155c157d.png)

-	기본적으로 Message를 생산하는 Producer, ActiveMQ Broker(Server), Message를 소비하는 Consumer로 구성되어 있다.

### ActiveMQ의 특징
-	다양한 언어와 프로토콜 지원 (JAVA, C, C++, C#, Ruby, Peri, Python, PHP 클라이언트)
-	OpenWire를 통해 고성능의 JAVA, C, C++, C# 클라이언트 지원
-	Stomp를 통해 C, Ruby, Peri, Python, PHP 클라이언트가 다른 인기있는 메시지 브로커들과 마찬가지로 ActiveMQ에 접근 가능
-	Message Groups, Virtual Destinations, Wildcards와 Composite Destination을 지원
-	Spring 지원으로 ActiveMQ는 Spring Application에 매우 쉽게 임베딩 될 수 있으며, Spring의 XML 설정 메커니즘에 의해 쉽게 설정 가능
-	Geronimo, JBoss 4, GlassFish, WebLogic과 같은 인기있는 J2EE 서버들과 함께 테스트됨
-	고성능의 저널을 사용할 때에 JDBC를 사용하여 매우 빠른 Persistence를 지원
-	REST API를 통해 웹 기반 메시징 API를 지원

 
## 카프카
-	아파치 카프카 (Apache Kafka)
-	대용량, 대규모 메시지 데이터를 빠르게 처리하도록 개발된 메시징 플랫폼
-	고성능 데이터 파이프라인, 스트리밍 분석, 데이터 통합 및 미션 크리티컬 애플리케이션을 위한 오픈 소스 분산 이벤트 스트리밍 플랫폼(distributed event streaming platform)이다.

### 이벤트 스트리밍 플랫폼
Kafka는 세 가지 주요 기능을 결합하여 end-to-end 이벤트 스트리밍을 구현할 수 있다.
-	이벤트 스트림을 지속적으로 **발행(publish-write)**, **구독(subscribe-read)**한다.
-	이벤트 스트림을 원하는 만큼 내구성 있고 안정적으로 **저장(store)**한다. KafkaCluster(broker)
-	이벤트 스트림을 발생 시 또는 소급하여 **처리(process)**한다.

### 주요 개념 및 용어
 ![image](https://user-images.githubusercontent.com/85390517/186664093-8e040412-5969-4bae-b757-695029f30c25.png)

-	KafkaCluster : 카프카의 브로커들의 모임. Kafka는 확장성과 고가용성을 위하여 broker들이 클러스터로 구성
-	Broker : 각각의 카프카 서버, 동일 노드에 여러 브로커를 띄울 수 있다.
-	Zookeeper : 카프카 클러스터 정보 및 분산처리 관리 등 메타데이터 저장. 카프카를 띄우기 위해 반드시 실행되어야 한다. (카프카 클러스터와 통합 예정)
-	Producer : 메시지(이벤트)를 발행하여 생산(Write) 하는 주체
-	Consumer : 메시지(이벤트)를 구독하여 소비(Read) 하는 주체

### 토픽, 파티션, 오프셋
 ![image](https://user-images.githubusercontent.com/85390517/186664112-410dd920-e23a-40c7-afd4-e09ddaed37e8.png)


+ 카프카에 저장되는 메시지는 topic으로 분류, topic은 여러 개의 partition으로 나뉘어진다.
+ Topic : 메시지를 구분하는 단위
  + 파일시스템의 폴더, 메일함과 유사함
+ Partition : 메시지를 저장하는 물리적인 파일
  + 한 개의 토픽은 한 개 이상의 파티션으로 구성된다.
  + 파티션은 메시지 추가만 가능한 파일(append-only)
+ Offset : 파티션 내 각 메시지의 저장된 상대적 위치
  + 프로듀서가 넣은 메시지는 파티션의 맨 뒤에 추가 (Queue)
  + 컨슈머는 오프셋 기준으로 마지막 커밋 시점부터 메시지를 순서대로 읽어서 처리함
  + 파티션의 메시지 파일은 처리 후에도 계속 저장되어 있으며 설정에 따라 일정시간 뒤 삭제됨

### 카프카의 특징
-	대용량 실시간 로그 처리에 특화되어 있다.
-	AMQP 프로토콜이나 JSM API를 사용하지 않고 단순한 메시지 헤더를 지닌 TCP 기반 프로토콜을 사용함으로써 오버헤드가 비교적 작다.
-	노드 장애에 대한 대응성을 가지고 있다.
-	프로듀서는 각 메시지를 배치로 브로커에 전달하며 TCP/IP 라운드 트립을 줄였다.
-	메시지를 기본적으로 파일 시스템에 저장하여 별도의 설정을 하지 않아도 오류 발생시 오류 지점부터 복구가 가능하다. (기존 메시징 시스템은 메시지를 메모리에 저장)
-	메시지를 파일 시스템에 저장하기 때문에 메시지가 많이 쌓여도 기존 메시징 시스템에 비해 성능이 크게 감소하지 않는다.
-	window 단위의 데이터를 넣고 꺼낼 수 있다.

### 대표적인 MQ들의 간단 비교
+ RabbitMQ
  + AMQP 프로토콜을 구현해 놓은 오픈소스이다.
+ ActiveMQ
  + JMS로 구현한 하나 이상의 클라이언트와 서버 간의 커뮤니케이션을 증진시키는 기능을 제공한다.
+ Apache Kafka
  + 대용량 실시간 로그 처리에 특화되어 설계된 메시징 시스템이다. TPS가 매우 우수하다.
  + 하지만, 특화된 시스템이기 때문에 범용 메시지 시스템에서 제공하는 다양항 기능들은 제공되지 않는다.
 
## ELK(elasticStack)
 ![image](https://user-images.githubusercontent.com/85390517/186664130-4333e67f-b3b0-4211-bfa8-8e78f2cfdc0d.png)

ELK는 위 그림과 같이 분석 및 저장 기능을 담당하는 Elastic Search, 수집 기능을 하는 Logstash, 이를 시각화 하는 도구인 Kibana의 앞 글자만 딴 단어이다. ELK는 접근성과 용이성이 좋아 최근 가장 인기있는 Log 및 데이터 분석 도구이다.

### ElasticSearch
-	ElasticSearch는 Lucene 기반으로 개발한 분산 검색엔진으로, Logstash를 통해 수신된 데이터를 저장소에 저장하는 역할을 담당한다.
-	데이터를 중심부에 저장하여 예상되는 항목을 검색하고 예상치 못한 항목을 밝혀낼 수 있다.
-	정형, 비정형, 위치정보, 메트릭 등 원하는 방법으로 다양한 유형의 검색을 수행하고 결합할 수 있다.
-	엘라스틱서치(ElasticSearch는 기본적으로 검색 엔진이다. 검색 엔진의 특성을 정확하게 이해하고 사용한다면 장점과 단점이 실 사용에 큰 영향을 미치지 않을 수 있다.
> 메트릭 : 보편적으로 메트릭이란 우리가 대시보드를 볼 때 특정 수치들을 그래프로 보여주는 일종의 시각화 (CPU 사용량, 시간당 데이터 처리량, 분당 네트워크 속도 등)

### Logstash
-	오픈소스 서버 측 데이터 처리 파이프라인으로, 다양한 소스에서 동시에 데이터를 수집하고 변환하여 stash 보관소로 보낸다.
-	수집할 로그를 선정해서, 지정된 대상 서버(ElasticSearch)에 인덱싱하여 전송하는 역할을 담당하는 소프트웨어

### Kibana
-	데이터를 시각적으로 탐색하고 실시간으로 분석할 수 있다.
-	시각화를 담당하는 HTML + Javascript 엔진이라고 보면 된다.
-	키바나(Kibana)의 경우 대체 가능한 소프트웨어로 그라파나(Grafana)가 있다. 데이터베이스 관리자가 주로 사용할 법한 기능을 일부 제외하고 사용자 인터페이스(UI) 측면을 강화한 특징이 있다.

### ELK Stack
 ![image](https://user-images.githubusercontent.com/85390517/186664156-c3ae07d8-9f9a-4c52-a472-7a5efceb2fe7.png)

-	ELK 솔루션에서 Beats 가 추가되면서 ELK Stack이라고 불린다.
-	Beats : 서버에 에이전트로 설치하여 다양한 유형의 데이터를 ElasticSearch 또는 Logstash에 전송하는 오픈 소스 데이터 발송자다.

### 장점
-	강력한 유연성과 호환성
-	자유 스키마
-	확장(Scale-out) 가능 데이터베이스
-	데이터 처리 절차를 ‘레거시 코딩’보단 개별 설정으로 가능
-	사전에 준비된 시각화 도구와 부가 기능
-	실시간 데이터 처리
-	엘라스틱서치의 버전 별 벌크(Bulk) 방법 차이를 완화

### 단점
-	초기 데이터 구성 및 이관 문제
-	커널 변수의 불필요한 사용
-	초창기부터 현재까지도 원활하지 못한 시간대(Timezone) 처리

 
## 레디스
-	NoSQL으로 Key-Value 타입 저장소이다.
-	영속성을 지원하는 인메모리 데이터 저장소이다. (In-memory)
-	보통 DB, Cache, 메시지 브로커 등의 용도로 사용된다.
-	읽기 성능 증대를 위해 Replication 지원
-	쓰기 성능 증대를 위해 샤딩(Sharding)을 지원
-	문자열뿐만 아니라 리스트, 해시, 셋 등 다양한 데이터 형식을 지원
-	1ms 이하 빠른 응답 시간을 지원한다.
-	파티셔닝 지원으로 스케일 아웃이 쉽다.
> 영속성 (Persistence) : 데이터를 생성한 프로그램의 실행이 종료되더라도 사라지지 않는 데이터의 특성을 의미한다.

### 레디스를 사용하는 이유
기본적으로 디스크가 아닌 램에 올려 사용하기 때문에 속도가 압도적으로 빠르다.

### 메모리의 필요성
-	레디스는 일반 데이터베이스와 달리 메모리를 사용하기 때문에 메모리 용량이 부족할 때가 많다.
-	메모리 부족으로 인한 메모리 스왑이 발생할 수 있다.
-	사용 목적에 따라 레디스 메모리를 설정해야 서비스의 장애를 대처할 수 있다.

### 메모리 단편화 문제
-	레디스는 jmalloc을 사용해 메모리 할당을 수행한다고 한다. 페이지 사이즈를 4096byte로 잡고 1byte의 데이터만 넣어도 4096byte를 할당한다. 이러한 현상을 내부단편화라고 한다.
-	이를 보완하기 위해서는 다양한 데이터 타입의 사용을 줄이고 유사한 크기의 데이터를 사용해야 한다.
 
## 도커
-	도커는 컨테이너 기반의 오픈 소스 가상화 플랫폼
-	가상화 : 물리적 자원인 하드웨어를 효율적으로 활용하기 위해서 하드웨어 공간 위에 가상의 머신을 만드는 기술
-	컨테이너 : 컨테이너가 실행되고 있는 호스트 os의 기능을 그대로 사용하면서 프로세스를 격리해 독립된 환경을 만드는 기술
-	도커는 **독립된 환경을 만들어서 하드웨어를 효율적으로 활용하는 기술**

### 도커를 사용하는 이유
+ 도커 허브에 올라온 이미지와 docker-compose.yml의 설정으로 원하는 프로그램을 편안하게 설치가 가능하다.
  + 컨테이너를 생성하여 분리된 환경에 설치하므로 제거도 쉽다.
+ 하나의 서버(로컬 호스트)에 포트만 변경하여 동일한 프로그램을 실행하기도 쉽다.
  + 도커를 사용하지 않으면 환경변수나 경로 등의 충돌과 같은 문제가 있다.

### 도커의 특징
+ 도커는 가상머신이 아니고 격리만 해주기 때문에 성능상 하락이 없다. (성능 하락이 큰 VM과 다르다.)
+ 확장성과 이식성
  + 도커가 설치되어 있다면 어디서든 컨테이너를 실행할 수 있다.
  + 오픈 소스이기 때문에 특정 회사나 서비스에 종속적이지 않다.
  + 쉽게 개발서버를 만들 수 있고 테스트 서버 생성도 가능하다.
+ 표준성
  + 도커를 사용하지 않는 경우, 각각의 언어로 만든 서비스들의 배포 방식은 모두 다르다.
  + 도커는 컨테이너라는 표준으로 서버를 배포하므로 모든 서비스들의 배포 과정이 동일해진다.
+ 이미지
  + 컨테이너를 실행하기 위한 압축파일과 같은 개념
  + 이미지에서 컨테이너를 생성하기 때문에 반드시 이미지를 만드는 과정이 필요하다.
  + Dockerfile을 이용하여 이미지를 만들고 처음부터 재현이 가능하다.
  + 빌드 서버에서 이미지를 만들면 해당 이미지를 이미지 저장소(허브)에 저장하고 운영서버에서 이미지를 불러와 사용한다.
+ 설정관리
  + 도커에서 설정은 보통 아래와 같이 환경변수로 제어한다.
  + MYSQL_PASS=password와 같이 컨테이너를 띄울 때 환경변수를 같이 지정한다.
  + 하나의 이미지가 환경변수에 따라 동적으로 설정파일을 생성하도록 만들어져야 한다.
+ 자원관리
  + 컨테이너는 삭제 후 새로 만들면 모든 데이터가 초기화된다. (제거가 쉽다.)
  + 그러므로 저장이 필요하다면, 업로드 파일을 외부 스토리지와 링크하여 사용하거나 S3같은 별도의 저장소가 필요하다.
  + 세션이나 캐시를 memcached나 redis와 같은 외부로 분리한다.
 
## 쿠버네티스
-	쿠버네티스란 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식성이 있고, 확장 가능한 오픈 소스 플랫폼이다.
-	쿠버네티스는 선언적 구성과 자동화를 모두 용이하게 해준다.
-	쿠버네티스 서비스, 기술 지원 및 도구는 어디서나 쉽게 이용할 수 있다.

### 쿠버네티스가 필요한 이유
쿠버네티스를 사용하면 컨테이너화된 애플리케이션 환경을 탄력적으로 실행할 수 있게 된다.

프로덕션 환경에서는 애플리케이션을 실행하는 컨테이너를 관리하고 가동 중지 시간이 없는지 확인해야 한다. 예를 들어, 컨테이너가 다운된다면 다른 컨테이너를 다시 시작하여 가동 중지 시간을 최소화하여야 한다.

이러한 문제를 시스템에 의해 관리하도록 하는 것이 쿠버네티스의 역할이다.

### 쿠버네티스가 제공하는 기능
+ 서비스 디스커버리와 로드 밸런싱
  + DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출
+ 스토리지 오케스트레이션
  + 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재
+ 자동화된 롤아웃과 롤백
  + 원하는 상태를 서술하고 현재 상태를 원하는 상태로 설정한 속도에 따라 변경 가능
+ 자동화된 빈 패킹
  + 각 컨테이너가 필요로 하는 CPU와 메모리(RAM)을 제공
+ 자동화된 복구 (self-healing)
  + 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체
+ 시크릿과 구성 관리
  + 암호, OAuth 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리
 
## 프로메테우스
-	프로메테우스는 메트릭 기반의 오픈소스 모니터링 시스템이다.
-	이벤트 모니터링 및 경고에 사용되는 무료 소프트웨어 응용 프로그램이다.
-	유연한 쿼리(PromQL) 및 실시간 경고가 가능하다.
-	구조가 간단해서 운영이 쉽고, 강력한 쿼리 기능을 가지고 있으며, 그라파나(Grafana)를 통한 시각화를 지원한다.
-	ELK와 같은 로깅이 아니라, 대상 시스템으로부터 각종 모니터링 지표를 수집하여 저장하고 검색할 수 있는 시스템이다.
-	Go 언어로 작성되었으며 아파치2 라이선스를 사용한다.
> 프로메테우스에서 **메트릭**이란?
> 수집하는 시계열 데이터를 말한다.
> 프로메테우스의 메트릭은 “메트릭명{필드1=값, 필드2=값} 샘플링데이터”와 같이 수집된다.

### 기능 및 구성
-	메트릭 수집, 시계열 데이터 저장
-	유연한 쿼리 언어인 PromQL을 통한 성능 분석
-	그라파나를 통한 데이터 시각화
-	Alertmanager를 통한 알림 생성
-	애플리케이션 코드 계측을 위한 클라이언트 라이브러리

### 장점
-	Pull 방식의 구조를 채택함으로써, 모든 메트릭의 정보를 중앙 서버로 보내지 않아도 된다.
-	Kubernetes 환경에서 설치가 쉽고, grafana와의 연동을 통한 운영이 쉽다.
-	Linux, Window 등의 OS metric 뿐 아니라 각종 Third-party의 다양한 exporter를 제공한다.
-	데이터 저장소가 시계열 데이터 저장소로 구현되어 있어, 많은 양의 정보를 빠르게 검색 가능하다.
-	구조가 복잡하지 않고 간단하기 때문에 특정 솔루션에 대한 export가 어렵지 않다.
-	모든 데이터를 수집하지 않고 일정 주기(기본 값:15초)로 메트릭을 수집하기 때문에 애플리케이션에 무리가 없다.

### 단점
-	클러스터링이 불가능하다. 프로메테우스를 여러 대 구성하려면 아래 그림처럼 Hierarchy 구조를 구성하여 사용해야한다.
-	모든 메트릭을 수집하지 않기 때문에 사실상 “추리”를 보는데에는 좋지만 APM(Application Performance Monitoring)과 같이 모든 로그를 추적하기에는 적합하지 않다. Pulling 하는 순간의 스냅샷 정보만 알 수 있다.
-	싱글 호스트 아키텍처이기 때문에 저장용량이 부족하면 디스크 용량을 늘리는 방법밖에 없다.
-	Prometheus server가 다운되거나, 설정 변경 등을 위해 재시작할 경우 메트릭이 일정시간동안 유실된다.
 ![image](https://user-images.githubusercontent.com/85390517/186664226-ce0d32a2-5690-4519-a8e7-c5ccb9289038.png)

 
## 그라파나 
-	그라파나는 오픈소스 메트릭 데이터 시각화 도구로 메트릭 분석 플랫폼을 지향하고 있다.
-	그라파나를 사용하면 저장된 위치에 상관없이 메트릭을 쿼리, 시각화, 경고 및 이해할 수 있다.
-	Prometheus, InfluxDB, Elasticsearch 등 여러 데이터 소스와 통합이 가능하다.
 ![image](https://user-images.githubusercontent.com/85390517/186664253-cf4669f6-d6de-4931-872f-72ffc8f0aba1.png)


### 그라파나와 키바나의 차이점
두 서비스의 가장 큰 차이점은 서비스의 목적에 있다.
-	그라파나는 시스템 관점인 CPU 메모리, 디스크 IO 및 사용률과 같은 메트릭스 지표를 시각화하는데 특화되어 있다.
-	반면 키바나는 엘라스틱 위에서 실행되며 주로 로그메시지 분석에 사용된다.
 
## 코틀린
JVM에서 동작하는 프로그래밍 언어

자바를 대체할 수 있는 언어로, 다음과 같은 프로그래밍이 가능한 멀티 플랫폼이다.
-	Kotlin/JVM – 자바 가상 머신 상에서 동작하는 앱(자바앱/안드로이드앱) 개발
-	Kotlin/JS – 자바스크립트에 의해 DB부터 서버, 클라이언트까지 다루는 풀스택 웹 개발
-	Kotlin/Native – 안드로이드와 IOS 뿐만 아니라 임베디드, IoT 등 앱 개발
즉 서버 안드로이드 등 자바가 실행되는 모든 곳에서 사용할 수 있다.

### 코틀린의 특징
+ 정적 타입 지정 언어
  + 모든 프로그램의 구성 요소를 컴파일 시점에 알 수 있고, 컴파일러가 타입을 검증해준다는 것이다.
  + 그래서 자바와 다르게 개발자가 타입을 선언하지 않아도 된다. (타입추론지원)
  + 개발자가 아니라 컴파일러가 프로그램의 정확성을 검증하기 때문에 프로그램이 오류로 중단될 가능성이 적어진다.
+ 코드 면에서 더 간결하다.

+ 자바
```java
class Java {
  public void main(String[] args) {
    System.out.println(“HelloWorld”);
  }
}
```

  + 코틀린
```kotlin
fun main() {
	print(“HelloWorld”)
}
```

+ Null 안정성
  + 코틀린은 널이 될 수 있는 타입도 지원한다.
  + 널 값 허용여부를 컴파일 단계에서 검사하기 때문에 널 포인터로 인한 프로그램 중단도 예방할 수 있다.
+ 함수 타입에 대한 지원
  + 코틀린은 함수형 프로그래밍(Functional Programming)을 지원한다.
  + 가독성을 높이고 유지보수를 용이하게 할 뿐만 아니라 함수를 통해 불변데이터 구조를 사용하기 때문에 다중 스레드를 사용해도 안정적이다.

### 결론적으로 코틀린을 사용하는 이유
코틀린은 자바와 호환도 잘 되면서 실용적으로 간결하고 안전한 언어이기 때문
-	자바와의 호환성
-	실용적
-	간결성
-	안전성

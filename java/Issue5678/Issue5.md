### 객체 지향 프로그래밍 (OOP, Object-Oriented Programming)
-	객체 지향 프로그래밍에서는 모든 데이터를 객체(object)로 취급하며, 이러한 객체가 바로 프로그래밍의 중심이 된다.
-	**객체(object)**란 간단히 이야기하면 실생활에서 우리가 인식할 수 있는 사물을 의미한다.
-	객체의 사전적 의미 : 물건 또는 대상
-	객체의 상태(state)와 행동(behavior)을 구체화하는 형태의 프로그래밍이 바로 객체 지향 프로그래밍이다.
 ![image](https://user-images.githubusercontent.com/85390517/193025850-50b20353-da08-4527-870a-16933c985023.png)

### 객체 지향의 4대 특성
+ 캡슐화(encapsulation)
+ 객체의 속성과 행위를 하나로 묶고 구현 내용 일부를 외부에 감추어 은닉할 수 있다.
+ 상속(inheritance)
  + 상위 클래스의 속성과 행위를 상속받을 수 있다. 하위 클래스는 필요한 특성을 추가하여 사용할 수 있다.
+ 추상화(abstraction)
  + 상세한 정보는 무시하고 필요성에 의해 있어야할 정보들만 간추려서 구성하는 것으로 공통점을 추출하는 것이다.
+ 다형성(polymorphism)
  + 같은 타입이지만 실행 결과가 다양한 객체를 대입할 수 있는 성질을 말한다.

### 클래스 (Class)란
자바에서 클래스(class)란 객체를 정의하는 틀 또는 설계도와 같은 의미로 사용된다.  자바에서는 이러한 설계도인 클래스를 가지고, 여러 객체를 생성하여 사용하게 된다.
-	클래스는 객체의 상태를 나타내는 필드(field)와 객체의 행동을 나타내는 메소드(method)로 구성된다.
-	즉, 필드(field)란 클래스에 포함된 변수(variable)을 의미한다.
-	또한, 메소드(method)란 어떠한 특정 작업을 수행하기 위한 명령문의 집합이라고 할 수 있다.

## 클래스 정의하는 방법
```java
class Member {
    // 필드(field)
    Long id;
    String name;

    // 생성자(constructor)
    public Member() {

    }

    // 메소드(method)
    void setName(String name){
        this.name = name;
    }
    
       ..
}
```

## 객체 만드는 방법 (new 키워드 이해하기)
```java
Member member = new Member();
// 클래스 변수 = new 클래스();
```
-	new 키워드는 새로운 객체(인스턴스)에 메모리를 할당하고 메모리에 대한 참조값을 반환하여 클래스를 인스턴스화 한다. 일반적으로 객체가 메모리에 할당되면 인스턴스라고 부른다.
### 객체의 생성 과정
1.	new 연산자가 메모리 영역에 저장공간을 할당받는다.
2.	생성자가 객체를 초기화한다.
3.	new 연산자가 새로 생긴 객체의 주소를 변수에 저장한다.
4.	변수를 통해 해당 객체에 접근한다.

### new 키워드의 특징
-	객체를 만드는데 사용된다.
-	런타임 메모리를 할당한다.
-	모든 객체는 힙 영역에서 메모리를 차지한다.
-	객체 생성자를 호출한다.
-	생성자를 호출하려면 단일 후위 인수가 필요하다.

### new 키워드로 생성한 객체의 메모리 할당
-	member는 (인스턴스의 메모리 주소를 가지고 있다.) 참조변수이지만 지역변수이므로 Stack 메모리에 저장된다.
-	new 키워드로 생성된 Member 인스턴스는 생성된 순간 Heap 메모리에 저장되고, member의 id, name 정보도 함께 Heap 메모리에 저장된다.
 ![image](https://user-images.githubusercontent.com/85390517/193026103-215ce65d-9702-4fd9-a76e-06f4f8188cb3.png)

-	new 연산자는 객체(인스턴스)를 생성시킨 후, 객체의 주소를 리턴 하도록 되어있다.

## 메소드 정의하는 방법
```java
접근제어자 반환타입 메서드이름 (매개변수 리스트) – 선언부
{
-	구현부
}

public void test() {
	// 메소드 내용
}

public int test2() {
	// 메소드 내용
	return 2;
}

public String test3(String str) {
	return str;
}
```
+ 메소드는 해당 객체의 행위(동작)를 나타낸다. 자바에서는 모든 메소드가 클래스에 존재하기 때문에 모든 함수가 메소드이다.
  + 인스턴스 메소드(instance method)
    + 인스턴스와 연관된 작업을 하는 메소드로 인스턴스 생성 후에 사용이 가능하다. 
    + 인스턴스 메소드 내부에서 **클래스 변수와 인스턴스 변수 모두 사용이 가능하다.**
+ 클래스 메소드(static method)
  + static 키워드를 가지고 있는 메소드 인스턴스와 관계가 없어 인스턴스를 생성하지 않아도 사용할 수 있다.
  + 클래스 메소드 내부에서는 인스턴스 변수를 사용할 수 없고 **클래스 변수와 지역 변수만 사용 가능하다.**
+ 반환 타입
  + 메소드가 작업을 수행하고 반환할 데이터의 타입을 명시
+ 메소드 이름
  + 메소드 이름은 동사여야 하며, camelCase 명명법을 따르고 뜻이 분명해야 한다.
+ 메소드 시그니처
  + 메소드 이름과 매개변수 리스트를 메소드 시그니처라고 부른다.
  + 컴파일러는 메소드 시그니처를 보고 구별할 수 있기 때문에 **메소드 오버로딩(method overloading)**을 지원한다.
  + 반환 타입은 메소드 시그니처가 아니기 때문에 반환 타입만 다른 경우에는 오버로딩을 할 수 없다.

## 생성자 정의하는 방법
### 생성자란
-	인스턴스를 생성해주고 클래스의 객체를 초기화하는데 사용되는 특수한 메소드라고 할 수 있다.
-	메소드와 달리 반환 값(반환 타입이 없다.)이 없기 때문에 `return`도 사용하지 않는다.
-	클래스와 이름이 같아야 하며 최소 1개 이상의 생성자를 가질 수 있다.
-	생성자가 한 개도 정의되지 않는 경우 `default` 생성자를 자동으로 추가한다.
-	반대로 한 개라도 생성된 경우 `default` 생성자는 생성되지 않는다.
-	객체 초기화 방법이 여러 개일 경우 여러 개의 생성자를 가질 수 있다.

### 생성자 생성
```java
class Con {
    private int number;

    // default 생성자
    public Con() {
        // 인스턴스 변수를 초기화할 수 있다.
    }

    // 여러가지 파라미터를 받을 수도 있다.
    // 인스턴스 변수의 타입들이 다를 경우에만 1개의 인자를 받을 수 있다.
    public Con(int number) {
        // 파라미터를 이용하여 인스턴스 변수를 초기화할 수 있다.
        this.number = number;
    }
}
```

### 생성자 호출
```java
public static void main(String[] args) {
        // new 키워드를 이용하여 생성자를 호출할 수 있다.
        Con con = new Con();
        Con con = new Con(55);
        }
```

## 초기화 블록 (initializer)
초기화 블록 내에서는 조건문, 반복문과 같은 제어문을 사용해 인스턴스 및 클래스 변수를 초기화할 수 있다.
+ 클래스 초기화 블록
  + 클래스 변수를 초기화할 수 있다.
+ 인스턴스 초기화 블록
  + 인스턴스 변수를 초기화할 수 있다.

```java
class Class {
    static String classVariable;
    String instanceVariable;

    // 클래스 초기화 블록
    static {
        classVariable = "Class Variable";
    }

    // 인스턴스 초기화 블록
    {
        instaceVariable = "Instance Variable";
    }
}
```

-	`static`, `public`과 같은 키워드들을 **제어자(modifier)**라고 하며, 클래스나 멤버 선언시 부가적인 의미를 부여한다.
+ 접근제어자
  + 접근지시자, 접근지정자 등 많은 이름으로 불리운다.
  + 해당 클래스 또는 멤버(변수, 메소드)를 정해진 범위에서만 접근할 수 있게 해준다.
  + 클래스의 경우 `public`과 `default` 접근제어자만 사용이 가능하다.
  + `default`의 경우는 아무것도 명시하지 않았을 때를 의미한다.

|접근제어자|설명|
|---|----------|
|static|객체를 생성하지 않아도 고정된 메모리 영역을 할당 받는다.(Static 영역)<br>객체를 생성하지 않아도 static 변수와 static 메소드를 사용할 수 있다.<br>stactic으로 선언된 변수와 메소드 등은 모든 객체가 공유할 수 있다.|
|final|클래스 앞에 붙으면 **해당 클래스는 상속될 수 없다.**<br>변수 또는 메소드 앞에 붙으면 **수정이나 오버라이딩을 할 수 없다.**|
|abstract|클래스 앞에 명시하면 추상 클래스가 되어 객체 생성이 불가능하다. 접근을 위해서는 상속받아야 한다.<br>변수 앞에 명시할 수 없다.<br>메소드에 명시할 경우 추상 클래스(abstract class) 내에서만 가능하다. 추상 메소드는 선언만 하고 추상 클래스를 상속한 클래스에서 구현해야 한다.|
|transient|변수 또는 메소드가 포함된 객체를 직렬화(Serialize)할 때 해당 내용은 무시된다. (데이터를 전송하고 싶지 않을 때)|
|synchronized|메소드는 한 번에 하나의 스레드에 의해서만 접근이 가능하다.|
|volatile|자바 변수를 메인 메모리에 저장하겠다는 것을 명시하는 것|

## this 키워드 이해하기
`this` 키워드는 인스턴스 자신을 가리키는 명령어이다. 인스턴스가 생성되지 않고도 사용할 수 있기 때문에 클래스 메소드에서는 `this`를 사용할 수 없다.
-	객체 자신의 참조값을 전달하고 싶을 때 사용할 수 있다.
```java
public class Test {
    int a;

    public Test(int a) {
        this.a = a;
    }

    public Test getTeset() {
        return this;
    }
} 
```
-	`this()`는 해당 클래스의 생성자를 호출할 수 있다. 생성자를 재사용하는데 쓰인다. (생성자 체이닝)
```java
public class Test {
    int a;
    int b;

    public Test(int a) {
        this.a = a;
    }

    public Test(int a, int b) {
        this(a);
        this.b = b;
    }
}
```

# Network
-	Net과 Work의 합성어
-	컴퓨터와 같은 노드들이 통신 기술을 통해 그물망처럼 연결되어 통신을 하는 형태를 뜻한다.

## TCP
+ 서버와 클라이언트 간에 데이터를 신뢰성 있게 전달하기 위해 만들어진 프로토콜
+ 인터넷 상에서 데이터를 메시지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜
+ 연결형 프로토콜, 가상 회선 방식을 제공한다.
+ 흐름제어 및 혼잡제어
+ 높은 신뢰성을 보장한다.
+ UDP보다 속도가 느리다.
+ 전이중(Full-Duplex), 점대점(Point to Poit) 방식
+ 3-way handshaking 과정을 통해 연결을 설정하고 4-way handshaking 과정을 통해 해제한다.

#### 3 way handshake와 4 way handshake
+ 3 way handshake는 TCP의 접속 과정, 4 way handshake는 TCP의 접속 해제 과정이다.
+ **포트(PORT) 상태 정보**
+ CLOSED : 포트가 닫힌 상태
+ LISTEN : 포트가 열린 상태로 연결 대기 중
+ SYN_RCV : SYNC 요청을 받고 상대방의 응답을 기다리는 중
+ ESTABLISHED : 포트 연결 상태
  + **플래그 정보**
    + SYN : 연결 설정 -> Sequence Number를 랜덤으로 설정하여 세션을 연결하는데 사용하며, 초기에 Sequence Number를 전송한다.
    + ACK : 응답 확인 -> 패킷을 받았다는 것을 의미
    + FIN : 연결 해제 -> 세션 연결을 종료시킬 때 사용되며, 더 이상 전송할 데이터가 없음을 의미

### TCP 3 way handshake
-	TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정하는 과정
-	TCP/IP 프로토콜을 이용해서 통신을 하는 응용 프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.
 ![image](https://user-images.githubusercontent.com/85390517/185089316-c5a9c633-682c-4722-89a7-b74ac7eec0b6.png)

 + **3단계 연결 성립**
1.	클라이언트는 서버에 접속을 요청하는 SYN(M) 패킷을 보낸다.
2.	서버는 클라이언트의 요청 패킷을 받고 요청을 수락한다는 ACK(M+1)과 SYN(N)이 설정된 패킷을 발송한다.
3.	클라이언트는 서버의 수락 응답 패킷을 받고 ACK(N+1)을 서버로 보낸다. 연결이 성립된다.

### TCP 4 way handshake
-	연결을 해제하는 과정이다. 여기서는 FIN 플래그를 이용한다.
 ![image](https://user-images.githubusercontent.com/85390517/185089351-2173509a-a47c-476b-a166-b9485474c845.png)

+ **4단계 연결 해제**
1.	클라이언트가 종료하겠다는 FIN 플래그를 전송한다. 이때 클라이언트는 FIN_WAIT 상태가 된다.
2.	서버는 클라이언트의 요철을 받고, 알겠다는 확인 메시지로 ACK를 보낸다. 그리고 나서 데이터를 모두 보낼 때까지 잠깐 TIME_OUT이 된다. 이때 서버는 CLOSE_WAIT 상태가 된다.
3.	데이터를 모두 보내고 통신이 끝났으면, 연결이 종료되었다는 FIN 플래그를 전송한다. 이때 서버는 LSAT_ACK 상태가 된다.
4.	클라이언트는 종료 메시지를 확인하였다는 ACK를 보낸다. 서버는 ACK 메시지를 받고 소켓 연결을 CLOSE 한다. 클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 것을 대비해 일정 시간동안 세션을 남겨놓고 잉여 패킷을 기다린다(TIME_WAIT).

### 흐름제어
-	송신 측과 수신 측의 데이터 처리 속도 차이를 해결하기 위한 기법
-	수신 측이 송신 측보다 데이터 처리 속도가 빠르면 문제없지만, 송신 측의 속도가 빠를 경우 문제가 생긴다.
-	수신 측에서 제한된 저장 용량을 초과한 이후에 도착하는 데이터는 손실될 수 있으며, 만약 손실된다면 불필요하게 응답과 데이터 전송이 송/수신 측 간에 빈번히 발생한다.
-	이러한 위험을 줄이기 위해 송신 측의 데이터 전송량을 수신 측에 따라 조절해야 한다.
#### 해결 방법
+ **Stop and Wait** : 매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법 <br/>
![image](https://user-images.githubusercontent.com/85390517/185089427-1ea9ffe0-01e8-452d-b35d-813cd6fa522b.png)

+ **Sliding Window** (Go Back N ARQ)
  + 수신 측에서 설정한 윈도우 크기만큼 송신 측에서 확인응답없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어 기법
  + 전송은 되었지만, acked를 받지 못한 byte의 숫자를 파악하기 위해 사용하는 protocol
+ **동작 방식** : 먼저 윈도우에 포함되는 모든 패킷을 전송하고, 그 패킷들의 전달이 확인되는 대로 이 윈도우를 옆으로 옮김으로써 그 다음 패킷들을 전송 <br/>
![image](https://user-images.githubusercontent.com/85390517/185089502-d63c3df7-a828-4c1b-916c-286257416f12.png)

+ **Window** : TCP/IP를 사용하는 모든 호스트들은 송신하기 위한 것과 수신하기 위한 2개의 Window를 가지고 있다. 호스트들은 실제 데이터를 보내기 전에 3 way handshaking을 통해 수신 호스트의 receive window size에 자신의 send window size를 맞추게 된다. <br/>
![image](https://user-images.githubusercontent.com/85390517/185089537-82fe0ec1-015a-4b9e-9757-2ac97206a2c5.png)


### 혼잡제어
-	송신 측의 데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결하기 위한 기법
-	송신 측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달된다. 만약 한 라우터에 데이터가 몰릴 경우, 자신에게 온 데이터를 모두 처리할 수 없게 된다. 이런 경우 호스트들은 또 다시 재전송을 하게 되고 결국 혼잡만 가중시켜 오버플로우나 데이터 손실을 발생시키게 된다. 따라서 이러한 네트워크의 혼잡을 피하기 위해 송신 측에서 보내는 데이터 전송 속도를 강제로 줄이게 되는데, 이러한 작업을 **혼잡제어**라고 한다.
-	네트워크 내에 패킷의 수가 과도하게 증가하는 현상을 **혼잡**이라 하며, 혼잡 현상을 방지하거나 제거하는 기능을 **혼잡제어**라고 한다.
-	흐름제어가 송신 측과 수신 측 사이의 전송속도를 다루는데 반해, 혼잡제어는 호스트와 라우터를 포함해 보다 넓은 관점에서 전송 문제를 다룬다.

#### 해결 방법
 
+ **AIMD(Additive Increase / Multiplicative Decrease)**
  + 처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window 크기(단위 시간 내에 보내는 패킷의 수)를 1씩 증가시켜가며 전송하는 방법
  + 패킷 전송에 실패하거나 일정 시간을 넘기면 패킷의 보내는 속도를 절반으로 줄인다.
  + 공평한 방식으로, 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만, 시간이 흐르면 평형 상태로 수렴하게 되는 특징
  + 문제점 : 초기에 네트워크의 높은 대역폭을 사용하지 못하여 오랜 시간이 걸리게 되고, 네트워크가 혼잡해지는 상황을 미리 감지하지 못한다. 즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식
+ **Slow Start (느린 시작)**
  + AIMD와 마찬가지로 패킷을 하나씩 보내면서 시작하고, 패킷이 문제없이 도착하면 각각의 ACK 패킷마다 window size를 1씩 늘려준다. 즉, 한 주기가 지나면 window size가 2배가 된다.
  + 전송속도는 지수 함수 꼴로 증가한다. 대신에 혼잡 현상이 발생하면 window size를 1로 떨어뜨리게 된다.
  + 처음에는 네트워크 수용량을 예상할 수 있는 정보가 없지만, 한 번 혼잡 현상이 발생하고 나면 네트워크의 수용량을 어느 정도 예상할 수 있다.
  + 그러므로 혼잡 현상이 발생하였던 window size의 절반까지는 이전처럼 지수 함수 꼴로 window size를 증가시키고 그 이후부터는 완만하게 1씩 증가시킨다.
+ **Fast Retransmit (빠른 재전송)**
  + 패킷을 받는 쪽에서 먼저 도착해야 할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보내게 된다.
  + 단, 순서대로 잘 도착한 마지막 패킷의 다음 패킷의 순번을 ACK 패킷에 실어서 보내게 되므로, 중간에 하나가 손실되게 되면 송신 측에서는 순번이 중복된 ACK 패킷을 받게 된다. 이것을 감지하는 순간 문제가 되는 순번의 패킷을 재전송해줄 수 있다.
  + 중복된 순번의 패킷을 3개 받으면 재전송을 하게 된다. 약간 혼잡한 상황이 일어난 것이므로 혼잡을 감지하고 window size를 줄이게 된다.
+ **Fast Recovery (빠른 회복)**
  + 혼잡한 상태가 되면 window size를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방식이다. 이 정책까지 적용하면 혼잡 상황을 한 번 겪고 나서부터는 순수한 AIMD 방식으로 동작하게 된다.

### 오류제어
-	전송 도중에 발생핳 부호 오류를 검출하고, 정확한 정보를 재현하는 기술
-	신뢰성 있는 서비스 제공을 위해 필요하다.
+ **오류 인지**
+ 오류를 제어하기 위해서는 먼저 오류가 발생했음을 인지해야 한다.
+ TCP에서 오류를 파악하는 방법은 크게 두 가지가 있다.
1.	수신 측에서 송신 측으로 명시적으로 NAK(NACK, 부정 응답)를 전송
2.	전송한 패킷에 대한 ACK가 오지 않거나 중복된 ACK가 전송될 때
+ 또, 중복된 ACK란 보통 3개 이상이 전달될 때 오류 발생으로 파악하여 1번 방법 사용시 송신 측에 NAK를 확인하는 새로운 로직이 필요하기 때문에 일반적으로 2번 방법을 적용해 오류를 인지한다.
#### 오류제어 방식
+ **Stop And Wait**  
![image](https://user-images.githubusercontent.com/85390517/185089623-d11d2dec-255b-4233-ad37-22e57808a20c.png)

  + 흐름제어에서 사용했던 이 방식으로도 기본적인 오류 제어가 가능하다.
  + 송신 측에서 패킷을 보내고, 보낸 패킷에 대한 응답이 오면 다음 패킷을 보내는 방식이기 때문에 만약 packet2를 보낸 후 timeout이 발생했다면, 즉 보낸 packet2에 대한 응답이 없다면, 이를 다시 전송하면 되는 것이다.
  + 만약 Sliding Window를 사용한다면? -> Sliding Window는 윈도우에 있는 여러 개의 데이터들을 연속적으로 보내는 방식이기에 이 경우 Stop And Wait 방식으로 오류제어를 한다면 Sliding Window를 이용하는 의미가 전혀 없다.
  + 이러한 이유로 **재전송 기반의 오류제어, ARQ (Automatic Repeat Request)**를 사용하게 된다.

+ **ARQ (Automatic Repeat Request)**
+ TCP는 기본적으로 재전송 기반의 오류 제어를 사용한다. 통신 중에 어떤 오류가 발생하면 송신 측에서 수신 측으로 해당 데이터를 재전송하는 방식을 사용하여 오류 발생 상황을 해결한다는 의미이다.
+ ARQ를 이용한 오류 제어 방식엔 크게 두 가지, **Go Back N**과 **Selective Repeat**이 있다.

+ **Go Back N**  
![image](https://user-images.githubusercontent.com/85390517/185089693-f362f0d6-8875-439b-ad9c-186ea3265cd3.png)

+ Go Back N 에서는 송신 측에서 여러 개의 데이터를 연속적으로 보내다가 오류가 발생한 데이터부터 다시 재전송하는 방식이다.
  + 위 그림에서, 송신 측에서 0~2 패킷을 보낸 후 수신 측은 이를 정상적으로 받은 후 송신 측에 ACK3을 전송해 3부터 전송하면 된다고 알린다.
  + 송신 측이 3~5를 보냈는데, 그 중 4번이 유실되어 수신 측이 받지 못했고, 수신 측은 오류가 발생한 4번 데이터 이후의 데이터는 모두 폐기한다. 즉, 수신 측에서 5번 데이터를 폐기한 후 4번이 유실되었음을 알린다.
  + 이때, 송신 측은 유실된 데이터인 4번부터 다시 데이터를 전송하게 되는데, 4~5를 재전송하여 오류를 해결한다.
+ 하지만 이러한 방식 역시 이미 수신한 데이터를 폐기하고 다시 재전송해야 한다는 단점이 존재한다. 이러한 단점을 보완한 것이 **Selective Repeat** 방식이다.

+ **Selective Repeat**
+ 오류가 발생한 데이터만을 골라서 재전송하는 방식이다.
  + 4번 패킷에서 오류가 발생했고 이를 수신 측이 송신 측에 알리지만, 수신 측은 이미 받은 5번 데이터를 폐기하지 않는다.
  + 송신 측은 오류가 발생한 4번 패킷 만을 재전송하고 수신 측이 이를 정상적으로 받으면 송신 측은 다시 6번부터 전송을 시작하면 되는 것이다.
  + 하지만 이때 수신 측의 수신 버퍼는 0,1,2,3이 차곡차곡 쌓이다가 4번을 수신하지 못하고 5번을 수신, 이후 4,6을 수신 -> 수신 측의 버퍼는 0-1-2-3-5-4-6 과 같은 순서가 된다.
  + 즉, Selective Repeat 방식에서는 수신 측의 버퍼에 순서가 보장되지 않는다는 단점이 존재한다. 때문에 수신 버퍼에 대한 재정렬이 필요하고, 이는 필연적으로 또 다른 버퍼 공간을 필요로 한다는 단점이 있다.

-	**Go Back N** VS **Selective Repeat**
 ![image](https://user-images.githubusercontent.com/85390517/185089917-4f8c25ff-aa4a-4511-8509-5b27f750aa4a.png)

-	Go Back N 처럼 재전송이냐, Selective Repeat처럼 재정렬이냐의 문제인데, 사실상 굉장히 복잡한 네트워크로 재전송을 거치는 것보다 수신 버퍼 재전송이 보다 간단하기에 기본적으로 Selective Repeat 방식을 많이 사용한다고 한다.
 
## UDP
-	데이터를 데이터그램 단위로 처리하는 프로토콜
-	데이터그램 : 독립적인 관계를 지니는 패킷
-	비연결형 프로토콜
-	정보를 주고받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다.
-	UDP 헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다.
-	신뢰성이 낮다.
-	데이터그램 단위로 쪼개면서 전송을 해야 하기 때문에 전송 계층이다.
-	TCP보다 속도가 빠르다.
-	**신뢰성보다 연속성이 중요한 서비스**, 예를 들어 실시간 서비스 등에 자주 사용된다.
<br/><br/>
#### TCP와 UDP의 비교
 ![image](https://user-images.githubusercontent.com/85390517/185089963-7209e345-e2e8-48cd-b9e0-30160ca7beb4.png)

 
## HTTP
-	Hyper Text Transfer Protocol
-	인터넷 상에서 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약
-	HTTP는 텍스트 교환이므로, 누군가 네트워크에서 신호를 가로채면 내용이 노출되는 보안 이슈가 존재한다. 이러한 보안 문제를 해결해주는 프로토콜이 HTTPS이다.

#### HTTP의 특징
+ 클라이언트 서버 구조
+ 무상태 프로토콜(Stateless) : 서버는 클라이언트를 식별할 수 없음
+ 비 연결성(Connectionless) : 클라이언트와 서버가 한 번 연결을 맺은 후, 클라이언트 요청에 대해 서버가 응답을 마치면 맺었던 연결을 끊어버리는 성질
  + 연결을 유지하기 위한 리소스를 줄여 더 많은 연결을 할 수 있다는 장점
  + 연결/해제에 대한 오버헤드가 발생한다는 단점
+ HTTP 메시지
+ 단순함, 확장 가능

#### 응답 상태 코드
+ 클라이언트가 서버에 요청을 하면, 서버는 요청에 대한 처리 상태를 숫자로 반환하는데 이를 **응답코드**라 한다.
+ 100 - 109
  + 메시지 정보
+ 200 – 206
  + 요청 성공
+ 300 – 305
  + 리다이렉션
+ 400 – 415
  + 클라이언트 에러
+ 500 – 505
  + 서버 에러

#### HTTP 메서드
+ 클라이언트가 서버로 요청을 할 때, 어떠한 목적을 갖는 행위인지 HTTP 메서드에 명시한다.
+ **GET**
  + 서버에게 리소스를 달라는 요청 (조회)
+ **HEAD**
  + 정확히 GET과 같지만, 서버는 응답으로 엔티티 본문 반환없이 헤더만을 반환
  + 클라이언트는 리소스를 가져올 필요없이 헤더만을 통해 정보를 얻을 수 있다.
+ **PUT**
  + 서버가 요청의 본문을 갖고 요청 URI의 이름대로 새 문서를 만들거나, 이미 URI가 존재한다면 요청 본문을 변경할 때 사용한다. (수정)
+ **POST**
  + 서버에 입력데이터를 전송하며 요청 엔티티 본문에 데이터를 넣어 서버에 전송한다. (삽입)
+ **DELETE**
  + 서버에서 요청 URI 리소스를 삭제하도록 요청한다. (삭제)
  + 클라이언트는 항상 삭제된다고 생각하지만, 서버에서는 이 요청을 무시할 수도 있다.
+ **TRACE**
  + 클라이언트와 목적지 서버 사이에 있는 모든 HTTP 애플리케이션의 요청/응답 연쇄를 따라가면서 자신이 보낸 메시지의 이상 유무를 파악한다.
  + 서버는 응답 메시지의 본문에 자신이 받은 요청메시지를 넣어 응답하며, 주로 진단을 위해 사용한다.
+ **OPTIONS**
  + 서버에게 특정 리소스가 어떤 메소드를 지원하는지 물어볼 수 있다.

### HTTP 버전
-	HTTP/0.9 : GET 메서드만 지원, HTTP 헤더 없음 -> HTML 문서만 전송 가능
-	HTTP/1.0 : 메서드, 헤더 추가 (HTML 이외 다른 파일 전송 가능)
-	HTTP/1.1 : 현재 HTTP/1.1 주로 사용, 우리에게 가장 중요한 버전
-	HTTP/2 : 성능 개선
-	HTTP/3 : 진행중, TCP 대신에 UDP 사용, 성능 개선
-	HTTP/1.1, HTTP/2는 TCP 기반이며 HTTP/3는 UDP 기반 프로토콜이다.
+ HTTP/1.0과 HTTP/1.1의 차이점
  + HTTP/1.0 : 요청을 보낼 때마다 연결을 해제하고 다시 TCP 세션을 맺어야 한다.
  + HTTP/1.1 : 한 개의 TCP 세션을 통해 계속 연결 가능하다.
 
## HTTPS
인터넷 상에서 정보를 암호화하는 SSL 프로토콜을 사용해 클라이언트와 서버가 자원을 주고받을 때 쓰는 통신 규약

### HTTPS가 필요 이유
-	HTTP 프로토콜은 서버에서부터 브라우저로 전송되는 정보가 암호화되지 않는다는 문제점이 있다. -> HTTPS 프로토콜은 SSL을 사용함으로써 이 문제를 해결
-	검색엔진 최적화(Google은 HTTPS로 설정된 사이트에 추가적인 검색 가산점을 준다고 한다.)
-	가속화된 모바일 페이지(AMP, Accelerated Mobile Pages : 모바일 기기에서 빠르게 콘텐츠를 로딩하기 위한 방법으로 Google이 개발함)

### HTTPS HandShake
 ![image](https://user-images.githubusercontent.com/85390517/185090003-065e9eed-cfb0-4c15-b765-cbe8a444119f.png)

1.	TCP 3way handshake를 우선적으로 거친다.
2.	Client : 컴퓨터가 자신의 버전, 암호 알고리즘 목록, 사용 가능한 압축 방식을 “ClientHello” 메시지에 담아 서버로 전송
3.	Server : 클라이언트가 제공한 암호 알고리즘 목록, 압축 방식 목록 중 선택 / 세션 ID, CA에서 사인한 서버의 공개 인증서를 “ServerHello” 에 담아 전송
4.	Client : 서버가 보낸 SSL 인증서가 CA 목록에 있는지 확인(크롬, 사파리 등 브라우저에 CA 목록이 탑재) -> SSL이 확인되면 클라이언트와 서버가 사용할 대칭키를 형성하기 위해 난수 바이트를 생성해 서버의 공개키로 암호화 후 전송
5.	Server : 클라이언트가 보낸 대칭키를 서버의 개인키로 복호화
 
## GET VS POST
#### GET
+ GET 메소드는 데이터를 호출하는 목적으로 사용한다.
+ URL에 파라미터를 추가하여 전송되기 때문에 보안에 취약하고 보내는 길이에 한계가 있으며 헤더에 담아서 보내진다.
+ 캐싱 기능이 있기 때문에 보안에 민감하지 않은 파라미터로 빠르게 조회해 오는데 유용한 방식이다.
+ 요청 형태 : www<k>.test.com?**id=tjrwn&major=computer**
+ 요청 데이터 : **id=tjrwn&major=computer**
#### POST
+ POST 메소드는 데이터를 저장하는 목적으로 사용한다.
+ 요청 데이터가 HTML Body에 들어가서 보내지기 때문에 외부에 요청 데이터가 노출되지 않고, 보낼 수 있는 데이터의 양도 제한이 없다.
캐싱 기능이 없기 때문에 빠르고 반복적으로 호출하는 경우에는 적합하지 않을 수 있다.
+ 요청 형태 : www<k>.test.com
+ 요청 데이터 : 노출되지 않음

 
## 쿠키와 세션
기본적으로 HTTP 프로토콜 환경은 비연결성(Connectionless), 무상태(Stateless)의 특성을 가지기 때문에 서버는 클라이언트가 누구인지 매번 확인해야 한다.
이러한 HTTP 프로토콜의 특성이자 약점을 보완하기 위해서 쿠키 또는 세션을 사용한다.

#### 쿠키
+ 쿠키는 클라이언트(브라우저) 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일이다.
+ 사용자 인증이 유효한 시간을 명시할 수 있으며, 유효 시간이 정해지면 브라우저가 종료되어도 인증이 유지된다는 특징이 있다.
+ 쿠키는 클라이언트의 상태 정보를 로컬에 저장했다가 참조한다.
+ 클라이언트에 300개까지 쿠키 저장 가능, 하나의 도메인당 20개의 값만 가질 수 있음, 하나의 쿠키 값은 4KB까지 저장

+ 쿠키의 동작 방식
1.	클라이언트가 페이지를 요청
2.	서버에서 쿠키를 생성
3.	HTTP 헤더에 쿠키를 포함시켜 응답
4.	브라우저가 종료되어도 쿠키 만료 기간이 있다면 클라이언트에서 보관하고 있음
5.	같은 요청을 할 경우 HTTP 헤더에 쿠키를 함께 보냄
6.	서버에서 쿠키를 읽어 이전 상태 정보를 변경할 필요가 있을 때 쿠키를 업데이트하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답

+ 쿠키의 사용 예
  + 방문 사이트에서 로그인 시, “아이디와 비밀번호를 저장하시겠습니까?”
  + 자동 로그인 
+ 팝업에서 “오늘 더 이상 이 창을 보지 않음” 체크

#### 세션
+ 세션은 쿠키를 기반하고 있지만, 사용자 정보 파일을 브라우저에 저장하는 쿠키와 달리 세션은 서버 측에서 관리한다.
+ 서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여하며 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증 상태를 유지한다.
+ 사용자의 정보를 서버에 두기 때문에 쿠키보다 보안에 좋지만, 사용자가 많아질수록 서버 메모리를 많이 차지하게 된다. -> 동접자 수가 많은 웹사이트인 경우 서버에 과부하를 주게되므로 성능 저하의 요인이 된다.

+ 세션의 동작 방식
1.	클라이언트가 서버에 접속 시 세션 ID를 발급받음
2.	클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장하고 가지고 있음
3.	클라이언트는 서버에 요청할 때, 이 쿠키의 세션 ID를 같이 서버에 전달해서 요청
4.	서버는 세션 ID를 전달받아서 별다른 작업 없이 세션 ID로 세션에 있는 클라이언트 정보를 가져와서 사용
5.	클라이언트 정보를 가지고 서버 요청을 처리하여 클라이언트에 응답

+ 세션의 특징
+ 각 클라이언트에게 고유 ID를 부여
+ 세션 ID로 클라이언트를 구분해서 클라이언트의 요구에 맞는 서비스를 제공
+ 보안 면에서 쿠키보다 우수
+ 사용자가 많아질수록 서버 메모리를 많이 차지하게 됨

+ 세션의 사용 예
+ 로그인 같이 보안에 중요한 작업을 수행할 때 사용

+ 세션은 사용자의 수만큼 서버 메모리를 차지하기 때문에, 최근에는 이러한 문제들을 보완한 토큰 기반의 인증 방식을 사용하는 추세이다.
#### Token 인증
+ 토큰 기반 인증 시스템은 클라이언트가 서버에 접속을 하면 해당 클라이언트에게 인증되었다는 의미로 ‘토큰’을 부여한다.
+ 이 토큰은 유일하며 토큰을 발급받은 클라이언트는 또 다시 서버에 요청을 보낼 때 요청 헤더에 토큰을 심어서 보낸다. 그러면 서버에서는 클라이언트로부터 받은 토큰을 서버에서 제공한 토큰과의 일치 여부를 체크하여 인증 과정을 처리하게 된다.
+ 토큰은 세션과는 달리 서버가 아닌 클라이언트에 저장되기 때문에 메모리나 스토리지 등을 통해 세션을 관리했던 서버의 부담을 덜 수 있다.
+ 토큰은 앱과 서버가 통신 및 인증할 때 가장 많이 사용된다. 웹에는 쿠키와 세션이 있지만 앱에서는 없기 때문이다.
+ Token 방식의 단점
  + 쿠키/세션과 다르게 토큰 자체의 데이터 길이가 길어, 인증 요청이 많아질수록 네트워크 부하가 심해질 수 있다.
  + Payload 자체는 암호화되지 않기 때문에 유저의 중요한 정보는 담을 수 없다.
+ Payload : 토큰에서 사용할 정보의 조각들인 Claim이 담겨있다. (실제 토큰을 통해 알 수 있는 데이터) 즉, 서버와 클라이언트가 주고받는 시스템에서 실제로 사용될 정보에 대한 내용을 담고 있는 섹션
+ 토큰을 탈취당하면 대처하기 어렵다. (사용 기간 제한을 설정하는 방식으로 극복한다.)
 
## REST와 RESTful의 개념
### REST**
Representational State Transfer
자원을 이름으로 구분하여 해당 자원의 상태를 주고받는 모든 것을 의미한다.
+ 즉 REST란
1.	HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고,
2.	HTTP Method(POST, GET, PUT, DELETE)를 통해
3.	해당 자원(URI)에 대한 CRUD Operation을 적용하는 것을 의미한다.
+ **CRUD Operation**
+ CRUD는 대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능인 Create, Read, Update, Delete를 묶어서 일컫는 말로 REST에서의 CRUD Operation 동작 예시는 다음과 같다.
  + Create : 데이터 생성(POST)
  + Read : 데이터 조회(GET)
  + Update : 데이터 수정(PUT)
  + Delete : 데이터 삭제(DELETE)

#### REST의 구성 요소
+ 자원(Resource) : HTTP URI
  + 모든 자원에는 고유한 ID가 존재하고, 이 자원은 Server에 존재한다.
  + Client는 URI를 이용해 자원을 지정하고 해당 자원의 상태(정보)에 대한 조작을 Server에 요청한다.
+ 자원에 대한 행위(Verb) : HTTP Method
  + HTTP 프로토콜의 Method를 사용한다. -> GET, POST, PUT, PATCH, DELETE
+ 자원에 대한 행위의 내용(Representations) : HTTP Message Pay Load
  + Client와 Server가 데이터를 주고받는 형태로 JSON, XML, TEXT, RSS 등이 있다.
  + JSON, XML을 통해 데이터를 주고받는 것이 일반적

#### REST의 특징
1.	Server-Client (서버-클라이언트 구조)
2.	Stateless (무상태)
3.	Cacheable (캐시 처리 가능)
4.	Layered System(계층화)
5.	Uniform Interface(인터페이스 일관성)

#### REST가 필요한 이유
-	애플리케이션 분리 및 통합
-	다양한 클라이언트의 등장
-	최근의 서버 프로그램은 다양한 브라우저와 안드로이드폰, 아이폰과 같은 모바일 디바이스에서도 통신을 할 수 있어야 한다.
-	이러한 멀티 플랫폼에 대한 지원을 위해 서비스 자원에 대한 아키텍처를 세우고 이용하는 방법을 모색한 결과, REST에 관심을 가지게 되었다.

#### REST API 간단 요약
URI는 정보의 자원만 표현해야 하며, 자원의 행위는 HTTP Method에 명시한다는 것이다.

### RESTful
+ RESTful은 일반적으로 REST라는 아키텍처를 구현하는 웹 서비스를 나타내기 위해 사용되는 용어이다.
+ ‘REST API’를 제공하는 웹 서비스를 ‘RESTful’하다고 할 수 있다.
+ RESTful은 REST를 REST답게 쓰기 위한 방법으로, 누군가가 공식적으로 발표한 것은 아니다.
+ 즉, REST 원리를 따르는 시스템은 RESTful이란 용어로 지칭된다.

#### RESTful의 목적
-	이해하기 쉽고 사용하기 쉬운 REST API를 만드는 것
-	RESTful한 API를 구현하는 근본적인 목적이 성능 향상에 있는 것이 아니라 일관적인 컨벤션을 통한 API의 이해도 및 호환성을 높이는 것이 주 동기이니, 성능이 중요한 상황에서는 굳이 RESTful한 API를 구현할 필요는 없다
 
## DNS 흐름
DNS란, 도메인 주소를 IP 주소로 변환하는 역할을 하는 서버이다.
도메인 주소 -> IP 주소로 변환하는 작업이 어떤 흐름으로 진행이 될까?
### DNS round robin 방식
Domain에 대한 IP 요청 쿼리 시 RR(Round Robin) 방식으로 IP를 반환한다.
시분할을 위한 선점형 스케줄링 중 한 방법인 RR은 프로세스에 우선순위를 두지 않고 순서대로 시간단위로 CPU를 할당하는 방식의 스케줄링 알고리즘이다.
즉, DNS 서버에 들어오는 IP 변환 요청들은 우선순위를 두지 않고, 시간단위로 응답을 해주는 방식이다.
이 방식으로 구성을 하면 자동적으로 시간에 따라 스케줄링이 변화되기 때문에 로드밸런서가 필요가 없다.
-	로드밸런서 : 한 서버에 여러 요청이 들어오면 부하가 생기기 때문에, 동일 기능을 하는 서버들 중 여유로운 서버에 트래픽을 나누는 것

### DNS Round Robin 방식의 문제점
+ 서버의 수만큼 공인 IP 주소가 필요하다.
+ DNS 서버에서 IP를 받기 때문이다.
+ 균등하게 분산되지 않는다.
+ 한 클라이언트의 요청 당 다음 서버에게 요청이 되어 분산이 되는 것처럼 보이지만, 다른 클라이언트들이 동시에 요청을 보낼 때 균등하게 트래픽을 분산시킨다고 가정하기는 어렵다.
+ 서버가 다운되어도 확인이 불가하다.
+ DNS 입장에서는 서버의 상태를 확인하지 않고 그냥 IP 주소만 알려주는 역할을 하기 때문에, 장애 발생 시 대처가 어렵다.
+ DNS 결과를 Caching하기 때문에 균등한 분산이 어렵다.

### Weighted roung robin (WRR)
가중치를 정해주는 RR 방식으로, 서버별로 가중치를 정해주고 이 가중치에 따라 분산을 해주는 방식이다.
서버의 성능이 높을수록 가중치를 높게 설정해주면 좋다.

### Least connection
서버에 접속한 클라이언트 수가 가장 적은 서버를 선택하여 알려주는 방식이다.
이는 로드밸런서에서 사용하는 방법인데, 로드밸런서는 서버당 connection의 수를 실시간으로 확인을 하여 트래픽이 낮은 서버를 판별해준다.

 
## Socket(TCP/IP Socket)
프로그램이 네트워크에서 데이터를 송수신하기 위한 실제적인 창구 역할을 한다. <br/>
서버와 클라이언트가 특정 포트를 통해 실시간으로 양방향 통신을 하는 방식
![image](https://user-images.githubusercontent.com/85390517/185090117-8913eaf0-861d-4939-9aac-05e189d8c934.png)

 
#### Socket은 프로토콜, IP 주소, 포트 넘버로 정의된다.
+ 프로토콜
  + 어떤 시스템이 다른 시스템과 통신을 원활하게 수용하도록 해주는 통신 규약, 약속
+ IP
  + 전 세계 컴퓨터에 부여된 고유의 식별 주소
+ 포트
+ 네트워크 상에서 통신하기 위해서 호스트 내부적으로 프로세스가 할당 받아야 하는 고유한 숫자
+ 한 호스트 내에서 네트워크 통신을 하고 있는 프로세스를 식별하기 위해 사용되는 값이므로, 같은 호스트 내에서 서로 다른 프로세스가 같은 포트 넘버를 가질 수 없다. 즉, 같은 컴퓨터 내에서 프로그램을 식별하는 번호이다.

### Socket 이전 실시간 통신 기술들
실시간 웹을 구현하기 위해서는 양방향 통신이 가능해야 하는데, Web Socket 이전에는 Polling, Streaming 방식의 Ajax 코드와 http를 이용한 실시간 통신 방식 COMET을 이용했다.

#### Polling
-	클라이언트에서 일정 주기마다 요청을 보내고 서버는 현재 상태를 바로 응답하는 방식
실시간으로 반영되는 것이 중요한 서비스에는 별로 좋지 않고 서버에서 변화가 없더라도 매 요청마다 응답을 내려주기 때문에 불필요한 트래픽이 발생하게 된다.

#### Long Polling
-	클라이언트에서 요청을 보내고 서버에서는 이벤트가 발생했을 때 응답을 내려주고 클라이언트가 응답을 받았을 때 다시 다음 응답을 기다리는 요청을 보내는 방식
실시간 반응이 가능하고 Polling에 비해 불필요한 트래픽은 유발하지 않지만 오히려 이벤트가 잦다면 순간적으로 과부하가 걸리게 된다.

#### Streaming
-	이벤트가 발생했을 때 응답을 내려주는데 응답을 완료시키지 않고 계속 연결을 유지하는 방식
Long Polling에 비해 응답마다 다시 요청을 하지 않아도 되므로 효율적이지만, 연결 시간이 길어질수록 연결의 유효성 관리의 부담이 발생한다.

#### COMET
-	COMET은 Client로 유의미한 메시지를 전달할 때까지 HTTP 응답을 지연시키는 기술이다.
서버가 클라이언트의 요청에 응답할 때 응답을 **늘어뜨리는** 방법을 이용해 긴 시간동안 브라우저가 접속을 끊지 않고 서버의 응답을 대기하도록 만드는 것이다.
Long Polling과 유사한 기능을 가진다.

### 클라이언트 소켓과 서버 소켓
두 개의 시스템(또는 프로세스)이 소켓을 통해 네트워크 연결을 만들기 위해서는, 최초 어느 한 곳에서 그 대상이 되는 곳으로 연결을 요청해야 한다. IP 주소와 포트 번호로 식별되는 대상에게 자신이 데이터 송수신을 위한 네트워크 연결을 수립할 의사가 있음을 알리는 것이다.

그런데 최초 한 곳에서 무작정 연결을 시도한다고 해서 그 요청이 무조건 받아들여지고 연결이 만들어져 데이터를 주고받을 수 있게 되는 것은 아니다. 한 곳에서 요청을 보내더라도 그 대상 시스템이 그 요청을 받아들일 준비가 되어있지 않다면, 해당 요청은 무시되고 연결은 만들어지지 않는다.

그러므로 요청을 받아들이는 곳에서는 어떤 연결 요청(일반적으로 포트 번호로 식별)을 받아들일 것인지를 미리 시스템에 등록하여, 요청이 수신되었을 때 해당 요청을 처리할 수 있도록 준비해야 한다.

이렇듯 두 개의 시스템(또는 프로세스)이 소켓을 통해 데이터 통신을 위한 연결(Connection)을 만들기 위해서는 연결 요청을 보내는지 또는 요청을 받아들이는지에 따라 소켓의 역할이 나뉘게 되는데, 전자에 사용되는 소켓을 클라이언트 소켓(Client Socket), 후자에 사용되는 소켓을 서버 소켓(Server Socket)이라고 한다.

### 소켓 API 실행흐름
![image](https://user-images.githubusercontent.com/85390517/185090193-ac08196c-f508-464a-8aed-1c50f8d6c860.png)
 
#### 클라이언트의 흐름
1.	**클라이언트 소켓 생성**
+ 연결 대상에 대한 정보가 들어있지 않은 Socket(껍데기 소켓)을 생성한다.
+ 이 때 소켓의 종류를 선택해야 하는데 TCP 소켓을 위해서는 stream 타입을, UDP 소켓을 위해서는 데이터그램 타입으로 지정이 가능하다.
2.	**연결 요청 (Connection)**
+ IP 주소와 서비스 포트 번호로 연결하고 싶은 타겟 대상을 특정한다.
+ 요청을 보내고 단순히 끝나는 것이 아니고, 그 요청에 대한 결과가 돌아와야만 Connect의 실행이 끝난다.
3.	**데이터의 송수신 (Send, Receive)**
+ 연결 요청과 같이 요청을 보낸다고 끝나는 것이 아니고, 요청에 대한 결과(신호)가 들어와야 실행이 끝난다.
+ 송신할 때에는 데이터를 보내는 것이기 때문에 데이터를 언제 얼마나 보낼 것인지 알 수 있지만, 수신할 때에는 상대방이 언제 얼만큼의 데이터를 보낼 것인지 알 수가 없다는 서로의 차이점이 존재한다.
+ 그렇기 때문에 수신하는 API가 별도의 Thread에서 진행하게 된다.
4.	**소켓 닫기**
+ 더 이상의 데이터 송수신이 없다고 판단되면 소켓을 닫는다.

#### 서버의 흐름
1.	서버 소켓 생성
+ 클라이언트 소켓과 마찬가지로 연결 대상에 대한 정보가 들어있지 않은 껍데기 소켓을 생성한다.
2.	바인딩 (bind)
+ 만약 서버 소켓이 받은 데이터를 다시 보내주어야 할 때 프로세스들의 포트 번호가 동일하다면 혼란이 생길 수 있다. 따라서 서버 소켓이 고유한 포트 번호를 만들 수 있도록 소켓과 포트 번호를 결합해주는 작업이 필요하다.
3.	클라이언트 연결 요청 대기
+ 클라이언트가 연결 요청을 할 때까지 기다리다가 연결 요청이 오면 대기 상태를 종료하고 리턴한다.
4.	클라이언트 연결 수립
+ 서버 소켓은 연결 요청을 받아들임과 동시에 새로운 소켓을 생성한다.
+ 서버 소켓의 메인 역할은 클라이언트 연결 요청을 기다리는 것이다. 따라서 클라이언트 소켓으로부터 연결 요청을 받으면 새로운 소켓을 열고, 이것과 클라이언트 소켓을 맵핑하여 넘겨준다.
5.	데이터 송수신 (Send, Receive)
+ 클라이언트와 동일
6.	소켓 닫기
+ 클라이언트와 동일하지만 서버 소켓은 자신이 생성한 소켓들도 관리를 해야한다.
 
## Web Socket(HttpSocket)
웹 소켓은 http에서 실시간 통신을 할 수 없다는 문제를 해결하기 위해 나온 기술로
두 프로그램 간의 메시지 교환을 위한 통신 방법 중 하나이다.
-	현재 인터넷 환경(HTML5)에서 많이 사용된다.
-	웹 소켓을 지원하는 브라우저의 경우 웹 소켓 프로토콜을 지원한다.
-	W3C와 IETF에 의해 자리잡은 표준 프로토콜 중의 하나
#### 웹 소켓의 특징
-	양방향 통신 (Full-Duplex)
-	실시간 네트워킹 (Real Time-Networking)
-	핸드 쉐이크 과정에서는 헤더의 비중이 크지만, 한 번 연결이 되면 간단한 메시지들만 오고 간다. -> 경제적

### Web Socket HandShake 및 실행 흐름
웹 소켓은 HTTP로 Handshake를 한 후 ws로 프로토콜을 변환하여 웹 소켓 프레임을 통해 데이터를 전송한다. 웹 소켓은 양방향 통신(full-duplex)을 지원하기 때문에 요청과 응답을 구분하지 않는다.
 ![image](https://user-images.githubusercontent.com/85390517/185090249-3449effa-d547-4bb5-a2f7-6bf515a844d4.png)

크게 붉은 박스로 표시된 **Opening Handshake**, 노란 박스로 표시된 **Data transfer**, 보라색 박스로 표시된 **Closing Handshake**의 세 가지 영역으로 나눌 수 있다.

1.	Opening Handshake
웹 소켓 클라이언트에서 핸드쉐이크 요청(HTTP Upgrade)을 전송하고 이에 대한 응답으로 핸드쉐이크 응답을 받는데, 이때 응답 코드는 101이다. 101ㄷ=은 ‘프로토콜 전환’을 서버가 승인했음을 알리는 코드이다.
이 과정에서 요청과 응답 헤더를 살펴본다. Ws://localhost:8080/chat으로 접속하려고 가정
 ![image](https://user-images.githubusercontent.com/85390517/185090272-ed3db11b-ec04-4e86-a9d4-0d31b0c09de5.png)

-	Upgrade : 프로토콜을 전환하기 위해 사용하는 헤더. 웹 소켓 요청 시에는 반드시 websocket이라는 값을 가지며, 이 값이 없거나 다른 값이면 cross-protocol attack이라고 간주하여 웹 소켓 접속을 중지시킨다.
-	Connection : 현재의 전송이 완료된 후 네트워크 접속을 유지할 것인가에 대한 정보. 웹 소켓 요청시에는 반드시 Upgrade라는 값을 가지며, Upgrade와 마찬가지로 이 값이 없거나 다른 값이면 웹 소켓 접속을 중지시킨다.
-	Sec-WebSocket-Key : 유효한 요청인지 확인하기 위해 사용하는 키 값
-	Sec-WebSocket-Protocol : 사용하고자 하는 하나 이상의 웹 소켓 프로토콜 지정
-	Sec-WebSocket-Version : 클라이언트가 사용하고자 하는 웹 소켓 프로토콜 버전
-	Origin : 모든 브라우저는 보안을 위해 이 헤더를 보낸다(Cross-Site WebSocket Hijacking과 같은 공격을 피하기 위해). 대부분 어플리케이션은 이 헤더가 없는 요청을 거부하며, 이러한 이유로 CORS 정책이 만들어졌다.

2.	Data transfer
핸드 쉐이크를 통해 웹 소켓 연결이 수립되면, 데이터 전송 파트가 시작된다. 여기에서는 클라이언트와 서버가 ‘메시지’라는 개념으로 데이터를 주고받는데, 여기서 메시지는 한 개 이상의 ‘프레임’으로 구성되어 있다. (프레임은 텍스트(UTF-8) 데이터, 바이너리 데이터, 컨트롤 프레임(프로토콜 레벨의 신호) 등이 있다.)
핸드 쉐이크가 끝난 시점부터 서버와 클라이언트는 서로가 살아있는지 확인하기 위해 heartbeat 패킷을 보내며, 주기적으로 ping을 보내 체크한다. 이는 서버와 클라이언트 양측에서 설정 가능하다.

3.	Closing Handshake
클라이언트와 서버 모두 커넥션을 종료하기 위한 컨트롤 프레임을 전송할 수 있다. 이 컨트롤 프레임은 Closing Handshake를 시작하려는 특정한 컨트롤 시퀀스를 포함한 데이터를 가지고 있다. 위 그림에서는 서버가 커넥션을 종료한다는 프레임을 보내고, 클라이언트가 이에 대한 응답으로 Close 프레임을 전송한다. 그러면 웹 소켓 연결이 종료된다. 연결 종료 이후에 수신되는 모든 추가적인 데이터는 버려진다.

### WebSocket 한계
웹 소켓은 HTML5 이후에 나왔다. HTML5 이전 기술로 구현된 서비스에서는 다음과 같은 기술들을 사용한다.
- Socket.io, SocketJS가 HTML5 이전의 기술로 구현된 서비스에서 웹 소켓처럼 사용할 수 있도록 도와주는 기술이다. 
- 브라우저와 웹서버의 종류와 버전을 파악하여 가장 적합한 기술을 선택해 사용한다.
> Socket.io 및 SocketJS
-	자바스크립트를 이용하여 브라우저 종류에 상관없이 실시간 웹을 구현할 수 있도록 한 기술
-	Node.js 라이브러리로 실시간 웹 기술을 손쉽게 사용할 수 있는 모듈
-	Websock, Polling, streaming 등 다양한 방법을 하나의 API로 추상화
-	브라우저의 종류에 상관없이 실시간 웹 구현 가능
-	웹 소켓은 문자열들을 주고받을 수 있게 해줄 뿐 그 이상의 일을 하지 않는다.
-	주고받는 문자열의 해독은 온전히 어플리케이션에 맡긴다.
-	HTTP는 형식을 정해 두었기 때문에 모두가 약속을 따르기만 하면 해석할 수 있다.
-	하지만 웹 소켓 방식은 sub-protocols을 사용해서 주고받는 메시지의 형태를 약속하는 경우가 많다. -> sub-protocols로 자주 쓰이는게 **STOMP**
> STOMP – SubSocket
-	웹 소켓 위에서 동작하는 프로토콜로써 클라이언트와 서버가 전송할 메시지의 유형, 형식, 내용들을 정의
 
## CORS
-	Cross – Origin Resource Sharing
-	직역하면 “교차 출처 리소스 공유”
브라우저에서는 보안적인 이유로 cross-origin HTTP 요청들을 제한한다. 
#### cross-origin
Cross-origin 이란 다음 중 한 가지라도 다른 경우를 말한다.
-	프로토콜 – http와 https는 프로토콜이 다르다.
-	도메인 – domain.com과 other-domain.com은 다르다.
-	포트 번호 – 8080포트와 3000포트는 다르다.

그래서 cross-origin 요청을 하려면 서버의 동의가 필요하다. 만약 서버가 동의한다면 브라우저에서는 요청을 허락하고, 동의하지 않는다면 브라우저에서 거절한다.
이러한 허락을 구하고 거절하는 메커니즘을 HTTP-header를 이용해서 가능한데, 이를 **CORS(Cross-Origin Resource Sharing)**라고 부른다.
 
## OSI 7Layer VS TCP/IP 4Layer VS TCP/IP 5Layer
#### OSI 7 Layer
네트워크에서 통신에서 일어나는 7단계 과정
#### 7 Layer로 나뉘어져 있는 이유
-	계층을 분리함으로써 각 계층은 독립적인 역할을 할 수 있다.
-	역할이 분리되면서 문제 발생 시 문제의 현상을 보았을 때 어떤 계층에 문제가 생겼는지도 파악이 가능하다.
-	각 계층은 하위 계층을 사용하고 현계층의 기능을 포함하여 상위 계층에 제공한다. (그래서 계층구조는 위에서 바라보았을 때 아래층이 보이지 않는 구조)
-	따라서 최상위 계층만 보면 그 아래 계층을 모두 포함하고 있다.

#### OSI 7 Layer vs TCP/IP 5 Layer
![image](https://user-images.githubusercontent.com/85390517/185090355-058dcc73-cfc7-4483-bf32-1f91a65bb6b2.png)

TCP/IP 모델은 4Layer 버전도 있지만 현재는 Updated 된 5 Layer가 널리 사용된다.
 
#### 공통점
-	두 모델 모두 계층형이다.
#### 차이점
-	TCP/IP는 인터넷 개발 이후 계속 표준화되어 신뢰성이 우수하다.
-	OSI 모델은 표준이 되기는 하지만 신뢰성이 저하되어 있다.
-	OSI 모델은 장비 개발과 통신 자체를 어떻게 표준으로 잡을지 사용된다.
-	실질적인 통신 자체는 TCP/IP 모델을 사용한다.
 
## 웹 통신 전체 흐름
![image](https://user-images.githubusercontent.com/85390517/185090396-a11a3412-e032-4d95-afae-a565e234368b.png)

주소창에 URL을 입력했을 때 통신의 흐름
 
**1) 2)** 사용자가 웹 브라우저를 통해 찾고 싶은 웹 페이지의 URL 주소를 입력한다.<br/>
**3)** 사용자가 입력한 URL 주소 중에서 도메인 네임(domain name) 부분을 DNS 서버에서 검색한다.<br/>
**4)** DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달한다.<br/>
**5) 6)** 웹 페이지 URL 정보와 전달받은 IP 주소는 HTTP 프로토콜을 사용하여 HTTP 요청 메시지를 생성한다.<br/>
**7)** 이렇게 도착한 HTTP 요청 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 URL 정보로 변환된다.<br/>
**8)** 웹 서버는 도착한 웹 페이지 URL 정보에 해당하는 데이터를 검색한다.<br/>
**9) 10)** 검색된 웹 페이지 데이터는 또 다시 HTTP 프로토콜을 사용하여 HTTP 응답 메시지를 생성한다.<br/>
이렇게 생성된 HTTP 응답 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 원래 컴퓨터로 전송된다.<br/>
**11)** 도착한 HTTP 응답 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 데이터로 변환된다.<br/>
**12)** 변환된 웹 페이지 데이터는 웹 브라우저에 의해 출력되어 사용자가 볼 수 있게 된다.
